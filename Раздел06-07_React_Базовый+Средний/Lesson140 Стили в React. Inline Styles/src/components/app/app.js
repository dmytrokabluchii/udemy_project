import { Component } from 'react';

import AppInfo from '../app-info/app-info';
import SearchPanel from '../search-panel/search-panel';
import AppFilter from '../app-filter/app-filter';
import EmployeesList from '../employees-list/employees-list';
import EmployeesAddForm from '../employees-add-form/employees-add-form';

import './app.css';

// function App() {
class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      data: [
        {name: 'Nika K.', salary: 800, increase: true, rise: true, id:1},
        {name: 'Nastya K.', salary: 3000, increase: false, rise: false, id:2},
        {name: 'Dima Kab.', salary: 5900, increase: true, rise: false, id:3}
      ],
      // Lesson 138. Практика. Реализуем поиск и фильтры
      // Строчку ниже мы будем получать из компонета SearchPanel в search-panel.js
      term: '',
      // Далее реализуем фильтр в поиске
      filter: 'all'
    }
    // Lesson 135 Д/З Создаем новое св-во для добавления нового сотрудника
    this.maxId = 4;
  }

  // Метод ниже теперь может перед-ся аж до самого нижнего уровня в employees-list-item.js и вызыв-ся уже только по клику
  deleteItem = (id) => {
    this.setState(({data}) => {
      // Теперь нам нужно взять наш id и по нему найти нужный объект внутри массива data и потом этот объект удалить
      // и уже после этого будем измен-ть state что-бы создать новое состояние
      // Прием ниже нужно запормнить, т.к. он часто испол-ся и он универсальный!
      // далее испол-м метод массива findIndex(), он принимает в себя callback фун-ю, кот-я запускается и если она
      // вернет true, то из этого метода будет возвращен номер элемента на котором сработала эта фун-я.
      // В callback фун-ю мы встав-м элемент(это каждый наш объект по порядку) и там мы будем сравнивать 
      // id у каждого элемента с тем id, т.е. тем аргументом что приходит из (id) в методе deleteItem 
      // и если мы найдем такое совпадение то у нас будет index того объекта кот-й нужно будет удалить

      // Способ 1:
      // const index = data.findIndex(elem => elem.id === id);
      // console.log(index);
      // И теперь нам нужно удалить объект кот-й мы нашли из нашего state
      // Сам объект при этом мы менять не можем(см. про immutable), т.к. это может вызвать много багов в React
      // и что-бы внести в него измен-я мы должны создать копию этого объекта с уже внесен-ми нововведениями
      // Метод splice поможет нам удалить опред-й элемент из нашего массива(при этом он изменит содер-е массива)
      // Код ниже просто удалит единст-й элемент(index) из массива data, но это протеворечит логики иммутабельности
      // и этот вариант нам не подходит, он неправильный!   data.splice(index, 1);
      // Создадим новый массив кот-й будет содер-ть все элементы старого, но уже без нужного нам элемента
      // Метод slice() возвращает новый массив, содержащий копию части исходного массива.
      // Начинаем с 1 элемента(0) и далее копируем лиш часть массива до того элемента что нам нужен(index)
      // const before = data.slice(0, index);
      // Ниже наш главный элемент мы пропускаем и после него копируем еще кусочек массива начиная со следующего
      // элемента и до конца массива, т.е. мы создали 2 кусочка массива содер-го половинки старого масссива
      // но уже без искомого элемента
      // const after = data.slice(index + 1);
      // Далее создаём новый массив, кот-й содер-т те же данные что и были в старом массиве, но без того элем-та что мы удалили!
      // const newArr = [...before, ...after];
      // Далее просто возвращаем новый сформированный массив
      // return { data: newArr }

      // Способ 2: берём массив data и отфильт-м его с формированием нового массива
      // Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.
      // И он подходит нам для сохранения мутабельности!
      return {
        // Ниже мы отфильтруем данные и у нас останутся только те элементы уникал-й id которого не совпадает с 
        // тем id что нам пришел и эта строчка заменяет нам способ 1 и в итого у нас вернет-ся новый массив!
        data: data.filter(item => item.id !== id)
      }
    })
  }

  // Lesson 135 Д/З Добавляем нового сотрудника с введенных в input данных
  addItem = (name, salary) => {
    const newItem = {
      name, 
      salary,
      increase: false,
      rise: false,
      // Когда созд-ся новый сотрудник то мы его просто увелич-м на 1  
      id: this.maxId++
    }
    this.setState(({data}) => {
      const newArr = [...data, newItem];
      return {
        data: newArr
      }
    });
  }

  // Lesson 128 Сэмитируем работу с сервером откуда у нас приходят данные, созд-м перм-ю с массивом данных
  // increase: true - добавит к элементу класс "increase", кот-й окрашивает наш текст в оранж-й(это прописано в css)
  // const data = [
  //   {name: 'Nika K.', salary: 800, increase: true, id:1},
  //   {name: 'Nastya K.', salary: 3000, increase: false, id:2},
  //   {name: 'Nika K.', salary: 5900, increase: true, id:3} ];

  // Lesson 136. Практика. Подъём состояния
  // Метод ниже будет изменять параметр Increase на противоп-й у определ-го элемента
  // По id мы будем определять что же у нас за элемент
  /* onToggleIncrease = (id) => {
    // Способ 1
    // this.setState(({data}) => {
    //   // И таким образом мы получим индекс элемента с которым будем работать!
    //   const index = data.findIndex(elem => elem.id === id);
    //   // Далее нам нужно взять объект по данному index и сделать его копию что бы мы могли что-то в нем поменять
    //   const old = data[index];
    //   // Развернем все св-ва внутри объекта old и сформи-т из этого новый объект
    //   // В результате мы получим новый сформир-й объект: {...old} и он не нарушает имутабельность. 
    //   // Далее после , мы можем добавлять новые св-ва и св-ва описанные после , если они будут совпадать со св-ми описанными в 
    //   // объекте old, то написанные после него будут его заменять
    //   // Т.е. мы создаём новой св-во increase: которое берет значение(true/false) меняет на противоп-е !old.increase и
    //   // записывает в increase. В резул-те в newItem у нас находится уже новый объект
    //   const newItem = {...old, increase: !old.increase};
    //   // Метод slice() возвращает новый массив, содержащий копию части исходного массива, где index + 1 это остаток от массива
    //   const newArr = [...data.slice(0, index), newItem, ...data.slice(index + 1)];
    //   return {
    //     data: newArr
    //   }
    // })

    // Способ 2 он по сути делает тоже самое что и 1-й способ
    this.setState(({data}) => ({
      // сформир-и новый массив испол-я метод map. В итоге мы получим массив объектов с новым измененным значением
      data: data.map(item => {
        // item.id каждый id внутри этого объекта и если он совпал с id пришедшим внутри метода onToggleIncrease, то
        // мы возвр-м новый объект в кот-й вкл-м все св-ва что были до этого ...item
        if (item.id === id) {
          return {...item, increase: !item.increase}
        }
        // И если условие выше не совпало, то мы просто возвр-м этот объект
        return item;
      })
    }))
  } */

  // Этот метод будет отвечать за переключение состояние сотрудника кот-й идет на повышение, он похож на метод onToggleIncrease 
  /* onToggleRise = (id) => {
    this.setState(({data}) => ({
      data: data.map(item => {
        if (item.id === id) {
          return {...item, rise: !item.rise}
        }
        return item;
      })
    }))
  } */

  // Объединим методы onToggleIncrease и onToggleRise в один onToggleProp
  // Где 2-й аргумент prop - это то что мы будем менять
  onToggleProp = (id, prop) => {
    this.setState(({data}) => ({
      data: data.map(item => {
        if (item.id === id) {
          return {...item, [prop]: !item[prop]}
        }
        return item;
      })
    }))
  }

  // Lesson 138. Реализуем метод поиска
  // Где 1-м аргументом приходит строчка по которой будем искать, а 2-м аргум-м будет массив данных что мы будем фильтровать
  searchEmp = (items, term) => {
    // Если пользователь ввел и удалил строку
    if (term.length === 0) {
      return items;
    }
    // И если условие не сработало нам нужно отфильтровать массив. мы будем брать св-во name из массива объектов и
    // искать совпадение со строчкой term, будем находить все совпадения что есть у нас в строках
    // В методе filter мы имеем callback фун-ю кот-я должна нам что-то возвращать
    return items.filter(item => {
      // Для обнаружения строчки будем испол-ть indexOf. Это метод для строки, кот-й позволяет искать подстроки
      // И если он ничего не найдет то вернет нам -1. Т.е. мы фильтруем и возвр-м только те элементы что проходят проверку
      // Мы берем name у каждого элемента массива, выпол-м метод indexOf на строке и пытаемся найти кусочек строки 
      // что прих-т в term и если у нас ничего не найд-ся мы верн-м -1 и это условие не выпол-ся,
      // а если найдено то верн-ся индекс где была найдена подстрока. 
      // Т.е. нам вернется массив элементов кот-й подходит под наш поиск!
      return item.name.indexOf(term) > -1
      // И далее в методе render() нам нужно будет отобразить эти данные
    })
  }

  // Метод ниже будет принимать строчку term и устанав-ть состояние внутри нашего гл. состояния в App.js
  onUpdateSearch = (term) => {
    // Где ({term}) - это сокращ-я запись ({term: term}) объектов
    this.setState({term: term})
  }

  // Метод для фильтрации. В верстке у нас всего 3 варианта для фильтра: все сотрудники, на повышение и с зп более 1000$
  filterPost = (items, filter) => {
    switch (filter) {
      case 'rise': 
            // Вернем только тех сотрудников у кого increase в позиции true
            // Т.е.месли у нас будет true то объект в массиве будет вкл-н
            return items.filter(item => item.rise);
            // item => if (item.rise) return это аналог сокр. записи item => item.rise
            // В констр-и switch - break после case можно не ставить
      case 'moreThen1000':  
          //  
          return items.filter(item => item.salary > 1000);
      // Если у нас не будет ни одного из фильтров, то мы просто не фильтруем ни один из элементов
      default:
          return items
    }
  }

  // Создадим еще один метод, кот-й мы будем передавать как действие во внутрь компонента
  onFilterSelect = (filter) => {
    // Возвр-м объект с фильтром, т.е. измен-м в нашем сост-и текущий фильтр
    this.setState({filter});
    // Далее передадим этот метод вниз по иерархии
  }

  render() {
    // Lesson 138
    const {data, term, filter} = this.state;
    // Lesson 136 Вывести кол-во сотрудников. Посчитаем общее кол-во сотрудников
    const employees = this.state.data.length;
    // Далее посчитаем кол-во сотрудников что получат премию и после фильльт-и мы получим их
    // this.state.data.filter(item => item.increase) - вернет нам массив, а для получ-я кол-ва просто добавим .length
    // И далее передадим эти данные ниже в AppInfo
    const increased = this.state.data.filter(item => item.increase).length;
    // В visibleData у нас будет массив, только отфильт-й по строчке что прих-т от другого компонета
    // const visibleData = this.searchEmp(data, term);
    // Одновременно с поиском у нас могут быть применены и фильтры
    // Ниже мы будем фильтровать отфил-й массив. Конечные данные что мы будем отобр-т на стр-це прох-т двойную фильт-ю
    // 1. по поиску this.searchEmp(data, term) и 2. по фильтрам filter
    const visibleData = this.filterPost(this.searchEmp(data, term), filter);

    return (
      <div className="app">
          <AppInfo
          employees={employees} increased={increased}
          />
          <div className="search-panel">
            {/* Передаем метод onUpdateSearch в SearchPanel и далее мы сможем его там испол-ть, в файле search-panel.js*/}
              <SearchPanel
                onUpdateSearch={this.onUpdateSearch}
              />
              <AppFilter
              // Перед-м текущий state
              filter={filter} onFilterSelect={this.onFilterSelect}
              />
          </div>
          {/* Передадим созд-й выше массив с данными, перед-м его в наш props(data) и потом мы сможем его испол-ть */}
          <EmployeesList 
            data={visibleData}
            // data={this.state.data}
            // Lesson 135 Это обычная стрел-я фун-я без () 
            // onDelete={id => console.log(id)}
            onDelete={this.deleteItem}
            // Прокинем методы выше вниз
            // onToggleIncrease={this.onToggleIncrease}
            // onToggleRise={this.onToggleRise}
            onToggleProp={this.onToggleProp}
          />
          <EmployeesAddForm
            onAdd={this.addItem}
          />
      </div>
    );
  }
  
}

// Экспортир-м по умолчанию наш компонент App
export default App;



// .findIndex()
// Метод findIndex() возвращает индекс в массиве, если элемент удовлетворяет условию проверяющей функции. 
// В противном случае возвращается -1.

// Что такое иммутабельность
// Неизменяемым (англ. immutable) называется объект, состояние которого не может быть изменено после создания. 
// Результатом любой модификации такого объекта всегда будет новый объект, при этом старый объект не изменится.

// splice()
// Метод splice() изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.

// slice()
// Метод slice() возвращает новый массив, содержащий копию части исходного массива.

// .filter()
// Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.

// .indexOf()
// Метод indexOf() возвращает индекс первого вхождения указанного значения в строковый объект String, на котором он был вызван, 
// начиная с индекса fromIndex. Возвращает -1, если значение не найдено.