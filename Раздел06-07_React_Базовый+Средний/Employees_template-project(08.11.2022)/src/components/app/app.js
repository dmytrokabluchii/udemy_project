import { Component } from 'react';

import AppInfo from '../app-info/app-info';
import SearchPanel from '../search-panel/search-panel';
import AppFilter from '../app-filter/app-filter';
import EmployeesList from '../employees-list/employees-list';
import EmployeesAddForm from '../employees-add-form/employees-add-form';

import './app.css';

// function App() {
class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      data: [
        {name: 'Nika K.', salary: 800, increase: true, id:1},
        {name: 'Nastya K.', salary: 3000, increase: false, id:2},
        {name: 'Dima Kab.', salary: 5900, increase: true, id:3}
      ]
    }
    // Lesson 135 Д/З Создаем новое св-во для добавления нового сотрудника
    this.maxId = 4;
  }

  // Метод ниже теперь может перед-ся аж до самого нижнего уровня в employees-list-item.js и вызыв-ся уже только по клику
  deleteItem = (id) => {
    this.setState(({data}) => {
      // Теперь нам нужно взять наш id и по нему найти нужный объект внутри массива data и потом этот объект удалить
      // и уже после этого будем измен-ть state что-бы создать новое состояние
      // Прием ниже нужно запормнить, т.к. он часто испол-ся и он универсальный!
      // далее испол-м метод массива findIndex(), он принимает в себя callback фун-ю, кот-я запускается и если она
      // вернет true, то из этого метода будет возвращен номер элемента на котором сработала эта фун-я.
      // В callback фун-ю мы встав-м элемент(это каждый наш объект по порядку) и там мы будем сравнивать 
      // id у каждого элемента с тем id, т.е. тем аргументом что приходит из (id) в методе deleteItem 
      // и если мы найдем такое совпадение то у нас будет index того объекта кот-й нужно будет удалить

      // Способ 1:
      // const index = data.findIndex(elem => elem.id === id);
      // console.log(index);
      // И теперь нам нужно удалить объект кот-й мы нашли из нашего state
      // Сам объект при этом мы менять не можем(см. про immutable), т.к. это может вызвать много багов в React
      // и что-бы внести в него измен-я мы должны создать копию этого объекта с уже внесен-ми нововведениями
      // Метод splice поможет нам удалить опред-й элемент из нашего массива(при этом он изменит содер-е массива)
      // Код ниже просто удалит единст-й элемент(index) из массива data, но это протеворечит логики иммутабельности
      // и этот вариант нам не подходит, он неправильный!   data.splice(index, 1);
      // Создадим новый массив кот-й будет содер-ть все элементы старого, но уже без нужного нам элемента
      // Метод slice() возвращает новый массив, содержащий копию части исходного массива.
      // Начинаем с 1 элемента(0) и далее копируем лиш часть массива до того элемента что нам нужен(index)
      // const before = data.slice(0, index);
      // Ниже наш главный элемент мы пропускаем и после него копируем еще кусочек массива начиная со следующего
      // элемента и до конца массива, т.е. мы создали 2 кусочка массива содер-го половинки старого масссива
      // но уже без искомого элемента
      // const after = data.slice(index + 1);
      // Далее создаём новый массив, кот-й содер-т те же данные что и были в старом массиве, но без того элем-та что мы удалили!
      // const newArr = [...before, ...after];
      // Далее просто возвращаем новый сформированный массив
      // return { data: newArr }

      // Способ 2: берём массив data и отфильт-м его с формированием нового массива
      // Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.
      // И он подходит нам для сохранения мутабельности!
      return {
        // Ниже мы отфильтруем данные и у нас останутся только те элементы уникал-й id которого не совпадает с 
        // тем id что нам пришел и эта строчка заменяет нам способ 1 и в итого у нас вернет-ся новый массив!
        data: data.filter(item => item.id !== id)
      }
    })
  }

  // Lesson 135 Д/З Добавляем нового сотрудника с введенных в input данных
  addItem = (name, salary) => {
    const newItem = {
      name, 
      salary,
      increase: false,
      // Когда созд-ся новый сотрудник то мы его просто увелич-м на 1  
      id: this.maxId++
    }
    this.setState(({data}) => {
      const newArr = [...data, newItem];
      return {
        data: newArr
      }
    });
  }

  // Lesson 128 Сэмитируем работу с сервером откуда у нас приходят данные, созд-м перм-ю с массивом данных
  // increase: true - добавит к элементу класс "increase", кот-й окрашивает наш текст в оранж-й(это прописано в css)
  // const data = [
  //   {name: 'Nika K.', salary: 800, increase: true, id:1},
  //   {name: 'Nastya K.', salary: 3000, increase: false, id:2},
  //   {name: 'Nika K.', salary: 5900, increase: true, id:3} ];

  // Lesson 136. Практика. Подъём состояния
  // Метод ниже будет изменять параметр Increase на противоп-й у определ-го элемента
  // По id мы будем определять что же у нас за элемент
  onToggleIncrease = (id) => {
    console.log(`Increase this ${id}`);
  }

  // Этот метод будет отвечать за переключение состояние сотрудника кот-й идет на повышение
  onToggleRise = (id) => {
    console.log(`Rise this ${id}`);
  }

  render() {
    return (
      <div className="app">
          <AppInfo/>
          <div className="search-panel">
              <SearchPanel/>
              <AppFilter/>
          </div>
          {/* Передадим созд-й выше массив с данными, перед-м его в наш props(data) и потом мы сможем его испол-ть */}
          <EmployeesList 
            // data={data}
            data={this.state.data}
            // Lesson 135 Это обычная стрел-я фун-я без () 
            // onDelete={id => console.log(id)}
            onDelete={this.deleteItem}
            // Прокинем методы выше вниз
            onToggleIncrease={this.onToggleIncrease}
            onToggleRise={this.onToggleRise}
          />
          <EmployeesAddForm
            onAdd={this.addItem}
          />
      </div>
    );
  }
  
}

// Экспортир-м по умолчанию наш компонент App
export default App;



// .findIndex()
// Метод findIndex() возвращает индекс в массиве, если элемент удовлетворяет условию проверяющей функции. 
// В противном случае возвращается -1.

// Что такое иммутабельность
// Неизменяемым (англ. immutable) называется объект, состояние которого не может быть изменено после создания. 
// Результатом любой модификации такого объекта всегда будет новый объект, при этом старый объект не изменится.

// splice()
// Метод splice() изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.

// slice()
// Метод slice() возвращает новый массив, содержащий копию части исходного массива.

// .filter()
// Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.