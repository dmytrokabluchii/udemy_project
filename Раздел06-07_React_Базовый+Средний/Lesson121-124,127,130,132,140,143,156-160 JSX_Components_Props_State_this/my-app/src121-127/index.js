// Импорт библ-ку react, и в данной версии это нужно делать только в этом файле(index.js), а не как в старых версиях в каждый .js файл
// Испол-я синтаксис деструктаризации импортируем также режим StrictMode при работе с нашим проектом
import React, {StrictMode} from 'react';
// Импорт библ-ки react-dom, нужна для работы react
import ReactDOM from 'react-dom/client';
import './index.css';
// Импортир-файл App.js, при этом .js не указываем, Webpack и так поймет, где App это импор-я функция из файла
import App from './App';
// Далее импортируем нашу "функцию-компонент" Header из App.js. 
// И далее мы сможем его испол-ть как обычн-ю фун-ю-компонет в качественашего хедера. Тоже самое можно делать и с 
import {Header} from './App';

// Создаем html-tag с внутр-ми испол-я синтакси react и помещаем его в перем-ю elem
// Тем самым мы смешиваем html и js, это удобно(т.к. мы можем сразу пропис-ть и логику) и это главная особенность JSX
// const elem = <h2>Hello World!</h2>;
// Участок кода выше назыв-ся react-элементом

// Если элемент будет иметь многострочную стр-ру, то его нужно помещать в ()
const text = 'Hello World!';
// Перем-ю пропис-м в {}, также там можно пропис-ть и мат. операции {3 + 9} и тд
// В {} мы не можем проп-ть объекты, {{}}, будет ошибка, но массив(это частный случай) можно, при этом он будет схлопываться,
// т.е. сконкотенируется(сложится в 1 строку), но на практике такое применяют нечасто!
// {['My age: ', 30 + 8]}    На стр-це мы увидим: My age: 38
// Все html-атрибуты в react пишутся в формате camelCase, при этом каждый посл-й атрибут пишется уже с Большой буквы!
// tabIndex={0} или tabIndex="0"
// В JS есть зарезир-е слова class и for, поэтому их пишем как: className='text' , htmlFor='id' 
// если мы это проигнорируем это то получим ошибку!
const elem = (
  <div>
    <h2 className='text'>{text}</h2>
    <h3>{3 + 9}</h3>
    <h4>{['My age: ', 30 + 8]}</h4>
    <input type="text" />
    <label htmlFor='id'></label>
    <button tabIndex={0}></button>
  </div>
);

// Также вариант выше мы можем переписать без испол-я JSX, как в обычном JS
// где 1-м арг-м идет назв-е эл-ты в верстке(тег h2), 2-м идет назв-е класса(если его нет то ставим null), и в 3-м идет содер-е нашего тега
// const elem2 = React.createElement('h2', null, 'Hello World2!');
// Вместо null можно передать и объект с именем класса
// const elem = React.createElement('h2', {className: 'greetings'}, 'Hello World2!');
// И в таком вариате Babel у нас уже работать не будет, он просто отправит без обработки файл

// библ-ки react-dom(вытаскивается выше из клиентсой части) и созд-т корневой узел, испол-я команду createRoot,
// далее указ-м селектор('root') куда хотим поместить наше созд-е прил-е
const root = ReactDOM.createRoot(document.getElementById('root'));
// И когда у нас созд-ся корень прил-я, испол-я команду render отрисовываем струк-ру нашего прилож-я
// Эта команда (root.render) в ReactDOM должна вызыв-ся только один раз на самом верхнем уровне прилож-я
// root.render(
//   // Поместим далее нашу стр-ру(элемент у нас) на страницу
//   elem
// );
root.render(
  // Испол-м StrictMode для потомка, т.е. для <App/>
  <StrictMode>
    <App/>
  </StrictMode> 
);

// А все остал-е прилож-е мы будем собирать по отдел-м файлам и заключать в фун-ю, например как импортир-я фун-я App





// Что такое JSX?
// Вместо того, чтобы искусственно разделить технологии, помещая разметку и логику в разные файлы, React разделяет 
// ответственность с помощью слабо связанных единиц, называемых «компоненты», которые содержат и разметку, и логику. 
// React можно использовать и без JSX, но большинство людей ценит его за наглядность при работе с UI, живущем в JavaScript-коде. 
// Помимо этого, JSX помогает React делать сообщения об ошибках и предупреждениях понятнее.
// JSX допускает использование любых корректных JavaScript-выражений внутри фигурных скобок. 
// Например, 2 + 2, user.firstName и formatName(user) являются допустимыми выражениями.
// JSX это тоже выражение
// После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.
// Из этого следует, что JSX можно использовать внутри инструкций if и циклов for, присваивать переменным, передавать функции
// в качестве аргумента и возвращать из функции.

// Использование атрибутов JSX
// Чтобы использовать строковый литерал в качестве значения атрибута, используются кавычки:
// const element = <a href="https://www.reactjs.org"> link </a>;
// Если же в значении атрибута требуется указать JavaScript-выражение, то на помощь приходят фигурные скобки:
// const element = <img src={user.avatarUrl}></img>;
// Не ставьте кавычек вокруг фигурных скобок, когда используете JavaScript-выражение в значении атрибута. Следует либо 
// применить кавычки (для строковых литералов), либо фигурные скобки (для выражений), но не то и другое вместе.
// Предупреждение:
// Поскольку JSX ближе к JavaScript чем к HTML, React DOM использует стиль именования camelCase для свойств вместо обычных имён HTML-атрибутов.
// Например, class становится className в JSX, а tabindex становится tabIndex.

// StrictMode
// Это инструмент для обнаружения потенциальных проблем в приложении. Также как и Fragment, StrictMode не рендерит видимого UI. 
// Строгий режим активирует дополнительные проверки и предупреждения для своих потомков.
// Примечание:
// Проверки строгого режима работают только в режиме разработки; они не оказывают никакого эффекта в продакшен-сборке.
// Строгий режим может быть включён для любой части приложения.


// Запуск данного react-приложения:
// cd my-app и npm start