// Заимпортируем все наши js файлы в главный(порядок значения не имеет), тем самым объединив их
require('es6-promise').polyfill();

import "core-js/stable";
import 'nodelist-foreach-polyfill';

import tabs from './modules/tabs';
import timer from './modules/timer';
import modal from './modules/modal';
import cards from './modules/cards';
import slider from './modules/slider';
import calc from './modules/calc';
import forms from './modules/forms';
import {openModal} from './modules/modal';

// Назначаем глобальный обработчик событий
window.addEventListener('DOMContentLoaded', () => {  
    // Через опред-й промежуток времени в () поместим фун-ю открытию мод. окна и устан. время его появ-я на сайте
    const modalTimerId = setTimeout(() => openModal('.modal', modalTimerId), 500000); 
    // Lesson 101-102 Модули + Webpuck. Т.к. переменные выше явл-ся функциями - вызовем их
    tabs('.tabheader__item', '.tabcontent', '.tabheader__items', 'tabheader__item_active');
    // Установим 2-м аргументом дату дедлайна для таймера
    timer('.timer', '2022-12-08');
    // В аргум-ты запишем нужные нам элементы со стр-цы(откр-е мод.окна)
    modal('[data-modal]', '.modal', modalTimerId);
    cards();
    // Перед-м в слайдер объект с опред-ми настр-ми(как это делается в плагинах)
    slider({
        container: '.offer__slider',
        slide: '.offer__slide',
        nextArrow: '.offer__slider-next',
        prevArrow: '.offer__slider-prev',
        totalCounter: '#total',
        currentCounter: '#current',
        wrapper: '.offer__slider-wrapper',
        field: '.offer__slider-inner'
    });
    calc();
    forms('form', modalTimerId);

});




// Lesson 82 JSON
// JSON.stringify()
// Метод преобразует значение JavaScript в строку JSON, возможно с заменой значений, если указана функция замены,
// или с включением только определённых свойств, если указан массив замены. Синтаксис:
// JSON.stringify(value[, replacer[, space]])
// value - Значение, преобразуемое в строку JSON.
// replacer (Необязательный) - Если является функцией, преобразует значения и свойства по ходу их преобразования в строку; 
// если является массивом, определяет набор свойств, включаемых в объект в окончательной строке.
// space (Необязательный) - Делает результат красиво отформатированным (расставляя пробелы).

// Lesson 84 
// Объект FormData позволяет создать набор пар ключ/значение и передать их, используя XMLHttpRequest. Объект FormData 
// предназначен для передачи данных форм, однако может быть использован для передачи пар ключ/значение независимо от форм. 
// Данные передаются в том же формате, как и данные, передаваемые методом submit() формы
// В html в <input> в форме обязат-но нужно прописывать имя (name="name")! Что-бы не было ошибок при работе с этим объектом

// .textContent
// Позволяет задавать или получать текстовое содержимое элемента и его потомков.

// .reset()
// очищаем данные в полях input после отправки

// Lesson 83
// XMLHttpRequest 
// Это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки 
// страницы. Мы можем загружать/скачивать файлы, отслеживать прогресс и многое другое.
// На сегодняшний день не обязательно использовать XMLHttpRequest, так как существует другой, более современный метод fetch.
// XMLHttpRequest()
// Конструктор XMLHttpRequest() создаёт новый объект XMLHttpRequest. Для отправки HTTP-запроса нужно создать 
// XMLHttpRequest-объект, открыть URL и отправить запрос. После выпол-я запроса можно получить и обраб-ть тело и статус ответа.
// XMLHttpRequest имеет два режима работы: синхронный и асинхронный.
// Синтаксис: const myRequest = new XMLHttpRequest();
//          Его метод open()
// Этот метод обычно вызывается сразу после new XMLHttpRequest. В него передаются основные параметры запроса:
// - method – HTTP-метод. Обычно это "GET" или "POST". "GET" для получ-я данных от сервера, "POST" для отправ-я данных на сервер.
// - URL – URL, куда отправляется запрос: строка, может быть и объект URL. Тут путь нужно формир-ть относит-но HTML
// - async – если указать false, тогда запрос будет выполнен синхронно, это мы рассмотрим чуть позже. 
// Синхронный код идет по порядку, т.е. код долго выпол-ся то код ниже будет ее ждать.
// Асинхронный работает иначе, он не блокирует остальной код, в основном испол-ся именно он!
// И по умолчанию Ajax-запросы являются асинхронным кодом
// - login, - password – логин и пароль для базовой HTTP-авторизации (если требуется). Пример:
//  request.open(method, url, async, login, password);
// Заметим, что вызов open, вопреки своему названию, не открывает соединение. Он лишь конфигурирует запрос, но непосредственно 
// отсылается запрос только лишь после вызова send.
//          Его HTTP-заголовки
// XMLHttpRequest умеет как указывать свои заголовки в запросе, так и читать присланные в ответ.
// Для работы с HTTP-заголовками есть 3 метода:
// - setRequestHeader(name, value);
// Устанавливает заголовок запроса с именем name и значением value. Например:
// request.setRequestHeader('Content-Type', 'application/json');
// - getResponseHeader(name);
// Возвращает значение заголовка ответа name (кроме Set-Cookie и Set-Cookie2). Например:
// request.getResponseHeader('Content-Type');
// - getAllResponseHeaders();
// Возвращает все заголовки ответа, кроме Set-Cookie и Set-Cookie2.
//           Послать запрос.
// request.send([body])
// Этот метод устанавливает соединение и отсылает запрос к серверу. Необязательный параметр body содержит тело запроса.
//          Когда мы уже отправили запрос, далее с ним нужно что-то делать, когда прийдет ответ от сервера
// для этого есть разл-е св-ва: 
// - status (404 и тд), есть отдел-й Список кодов состояния HTTP(в ссылках к уроку)
// - statusText: 404 Not Found («не найдено»)
// - response - это будет наш ответ от сервера, это тот ответ что задал backend-разработчик и мы будем испол-ть на клиенте
// - readyState - это текущее сост-е нашего запроса
// Свойство XMLHttpRequest.readyState возвращает текущее состояние объекта XMLHttpRequest. Объект request может иметь следующие состояния:
// Значение	Состояние	        Описание
//  0	    UNSENT	            Объект был создан. Метод open() ещё не вызывался.
//  1	    OPENED	            Метод open() был вызван.
//  2	    HEADERS_RECEIVED	Метод send() был вызван, доступны заголовки (headers) и статус.
//  3	    LOADING	Загрузка;   responseText содержит частичные данные.
//  4	    DONE	            Операция полностью завершена.
// И на основании этих св-в мы будем сторить дальнейшее взаимод-е
//          У объекта XMLHttpRequest также есть события кот-е относ-ся к нему. События на request, чтобы получить ответ.
// Три наиболее используемых события:
// - load – происходит, когда получен какой-либо ответ, включая ответы с HTTP-ошибкой, например 404.
// Изменения в состоянии объекта запроса генерируют событие readystatechange:
// - error – когда запрос не может быть выполнен, например, нет соединения или невалидный URL.
// - progress – происходит периодически во время загрузки ответа, сообщает о прогрессе.
//          Отмена запроса
// Если мы передумали делать запрос, можно отменить его вызовом request.abort():


// Lesson 85
// getAttribute()
// возвращает значение указанного атрибута элемента. Если элемент не содержит данный атрибут, 
// могут быть возвращены null или "" (пустая строка);

// insertAdjacentElement()
// Метод insertAdjacentElement() добавляет переданный элемент в DOM-дерево относительно элемента, вызвавшего метод. Синтаксис:
// targetElement.insertAdjacentElement(position, element);
// position: 'beforebegin': перед самим элементом targetElement.
// 'afterbegin': внутри элемента targetElement, перед его первым потомком.
// 'beforeend': внутри элемента targetElement, после его последнего потомка.
// 'afterend': после самого элемента targetElement.
// element: Элемент, добавляемый в DOM-дерево.
// Возвращаемое значение: Метод возвращает добавляемый элемент, либо null, если добавление элемента завершилось ошибкой.

// Lesson 87 Fetch API
//      Fetch API предоставляет интерфейс JavaScript для работы с запросами и ответами HTTP. Он также предоставляет глобальный 
// метод fetch() (en-US), который позволяет легко и логично получать ресурсы по сети асинхронно.
// Подобная функциональность ранее достигалась с помощью XMLHttpRequest. Fetch представляет собой лучшую альтернативу, 
// которая может быть легко использована другими технологиями, такими как Service Workers. Fetch также обеспечивает 
// единое логическое место для определения других связанных с HTTP понятий, такие как CORS и расширения для HTTP.
// Обратите внимание, fetch спецификация отличается от jQuery.ajax() в основном в двух пунктах:
// - !!! Promise возвращаемый вызовом fetch() не перейдёт в состояние "отклонено" из-за ответа HTTP, который считается ошибкой, 
// даже если ответ HTTP 404 или 500. Вместо этого, он будет выполнен нормально (с значением false в статусе ok ) 
// и будет отклонён только при сбое сети или если что-то помешало запросу выполниться.
// - По умолчанию, fetch не будет отправлять или получать cookie файлы с сервера, в результате чего запросы будут осуществляться 
// без проверки подлинности, что приведёт к неаутентифицированным запросам, если сайт полагается на проверку пользовательской 
// сессии (для отправки cookie файлов в аргументе init options должно быть задано значение свойства credentials отличное от 
// значения по умолчанию omit).
//      fetch()
// Есть несколько способов делать сетевые запросы и получать информацию с сервера.
// Метод fetch() Базовый синтаксис:
// let promise = fetch(url, [options])
// url – URL для отправки запроса.
// options – дополнительные параметры: метод, заголовки и так далее.
// Без options это простой GET-запрос, скачивающий содержимое по адресу url.
// Браузер сразу же начинает запрос и возвращает промис, который внешний код использует для получения результата.
//      Во-первых, promise выполняется с объектом встроенного класса Response в качестве результата, как только сервер 
// пришлёт заголовки ответа. На этом этапе мы можем проверить статус HTTP-запроса и определить, выполнился ли он успешно, 
// а также посмотреть заголовки, но пока без тела ответа.
// Промис завершается с ошибкой, если fetch не смог выполнить HTTP-запрос, например при ошибке сети или если нет такого сайта. 
// HTTP-статусы 404 и 500 не являются ошибкой. Мы можем увидеть HTTP-статус в свойствах ответа:
// status – код статуса HTTP-запроса, например 200.
// ok – логическое значение: будет true, если код HTTP-статуса в диапазоне 200-299.
// Например:
// let response = await fetch(url);
// if (response.ok) { // если HTTP-статус в диапазоне 200-299
//    получаем тело ответа (см. про этот метод ниже)
//   let json = await response.json();
// } else {
//   alert("Ошибка HTTP: " + response.status);
// }
//      Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.
// Response предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах:
// response.text() – читает ответ и возвращает как обычный текст,
// response.json() – декодирует ответ в формате JSON,
// response.formData() – возвращает ответ как объект FormData (разберём его в следующей главе),
// response.blob() – возвращает объект как Blob (бинарные данные с типом),
// response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),
// помимо этого, response.body – это объект ReadableStream, с помощью которого можно считывать тело запроса по частям. 
// Мы рассмотрим и такой пример несколько позже.
// Например, получим JSON-объект с последними коммитами из репозитория на GitHub:
// let url = 'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits';
// let response = await fetch(url);
// let commits = await response.json(); // читаем ответ в формате JSON
// alert(commits[0].author.login);
// ! Важно запомнить что: Promise возвращаемый вызовом fetch() не перейдёт в состояние "отклонено" из-за ответа HTTP, 
// который считается ошибкой, даже если ответ HTTP 404 или 500.  Вместо этого, он будет выполнен нормально 
// (с значением false в статусе ok ) и будет отклонён только при сбое сети или если что-то помешало запросу выполниться.
// Главное для этого метода что он вообще смог сделать этот запрос

// Итого
// Типичный запрос с помощью fetch состоит из двух операторов await: Или, без await:
//      Параметры ответа:
// response.status – HTTP-код ответа, т.е. тот статус что вернул нам сервер(404 и тд)
// response.ok – true, т.е. все хорошо, если статус ответа в диапазоне 200-299.
// response.headers – похожий на Map объект с HTTP-заголовками.
//      Методы для получения тела ответа:
// response.text() – возвращает ответ как обычный текст,
// response.json() – преобразовывает ответ в JSON-объект,
// response.formData() – возвращает ответ как объект FormData (кодировка form/multipart, см. следующую главу),
// response.blob() – возвращает объект как Blob (бинарные данные с типом),
// response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневые бинарные данные),
//      Опции fetch, которые мы изучили на данный момент:
// method – HTTP-метод,
// headers – объект с запрашиваемыми заголовками (не все заголовки разрешены),
// body – данные для отправки (тело запроса) в виде текста, FormData, BufferSource, Blob или UrlSearchParams.


// Lesson 89 - работа с JSON-Server
// Команда запуска JSON-Server в терминале VS-code на Windows 10: npx json-server db.json
// после запуска сервера командой: npx json-server db.json  мы увидем такие пути куда можно делать запросы в терминале:
// Resources
// http://localhost:3000/menu
// http://localhost:3000/requests
// Home
// http://localhost:3000
// В будущем нужно будет запускать и локальный сервер и JSON-Server для работы с этим и др. проектами!


// Lesson 90. Получение данных с сервера. Async/Await (ES8)
// Async/await
// async - ставится перед функцией и говорит что внутри будет асинх-й код, эта функция всегда будет возвращать промис. 
// Ключевое слово async перед функцией гарантирует, что эта функция в любом случае вернёт промис.
// await - можно использовать только внутри async-функций и ставит-ся только перед теми операциами, т.е перед тем кодом, 
// например перед fetch(), выпол-е кода которых нужно дожд-ся(например подождать пока не прийдут данные от сервера в методе fetch)
// Оперераторы async/await всегда испол-ся в паре!
// После отправки данных с формы мы увидим их не только в консоли но и в нашем db.json в объекте "requests":

// Object.entries()
// Метод Object.entries(obj) – возвращает массив пар [ключ, значение].
// Object.fromEntries
// Используем Object.fromEntries(array) на результате, чтобы преобразовать его обратно в объект.

// Error
// Конструктор Error создаёт объект ошибки. Экземпляры объекта Error выбрасываются при возникновении ошибок во время 
// выполнения. Объект Error также может использоваться в качестве базового для пользовательских исключений. 
// throw
// Инструкция throw позволяет генерировать исключения, определяемые пользователем, т.е. позволяет 
// выкидывать текст ошибки выше. Например:
// throw "Error2"; // генерирует исключение, значением которого является строка

// Деструктуризация
// Деструктурирующее присваивание в JavaScript — это изящный способ извлечения значений из массивов и объектов, при котором 
// в полной мере реализуется принцип DRY (англ. Don’t repeat yourself — «Не повторяйся»).
// Т.е. - это когда мы из объекта(напр. db.json) вытаск-м отдел-е св-ва в качестве отдел-й перем-й {img, altimg}


// Lesson 91. Что такое библиотеки. Библиотека axios. CDN
//      CDN
// CDN (Content Delivery Network - сеть доставки контента) - это группа серверов, расположенных во многих местах. 
// Эти сервера хранят дубликаты данных, чтобы сервера могли выполнять запросы данных на основе того, какие сервера ближе всего к 
// конечным пользователям. CDN увеличивают скорость доступа к сервису уменьшая влияние высокого трафика.
//      Axios
// Axios — это широко известная JavaScript-библиотека. Она представляет собой HTTP-клиент, основанный на промисах и 
// предназначенный для браузеров и для Node.js. Он изоморфный (= он может работать в браузере и node.js 
// с той же базой кодов). На стороне сервера он использует нативный node.js http-модуль, тогда как на стороне клиента (браузер) 
// он использует XMLHttpRequests. 
// Особенности:
// 1. Делает XMLHttpRequests запросы из браузера; 2. Делает http запросы из node.js;
// 3. Поддерживает Promise API; 4. Перехватывает запросы и ответы;
// 5. Преобразовывает данные запроса и ответа; 6. Отменяет запросы;
// 7. Автоматическое преобразование для JSON-данных; 8. Поддержка на стороне клиента для защиты от XSRF


// Lesson 92=93. Слайдер 
//      window.getComputedStyle()
// Метод Window.getComputedStyle() возвращает объект, содержащий значения всех CSS-свойств элемента, полученных после 
// применения всех активных таблиц стилей, и завершения базовых вычислений значений, которые они могут содержать. 
// Некоторые CSS-свойства доступны через API, предоставляемые объектом, или индексацию по именам CSS-свойств.
// Синтаксис:
// var style = window.getComputedStyle(element [, pseudoElt]);
// element - Element, свойства которого необходимо получить.
// pseudoElt (Необязательный) - Строка указывающая на найденный псевдо-элемент. Опускается (или null) для не псевдо-элементов.
// Возвращённый style живой CSSStyleDeclaration объект, который обновляется автоматически когда элемент стилей изменяется.
// Выводы: Метод Window.getComputedStyle() предоставляет все значения CSS-свойств элементов после применения текущей таблицы 
// стилей или базового расчёта каких-либо значений, которые могут быть.

// .slice()
// Метод slice() извлекает часть строки и возвращает новую строку без изменения оригинальной строки.


// Lesson 97-98. Создаем калькулятор на сайте
//      Формула расчета базовой нормы калорий:
// для мужчин: BMR = 88.36 + (13.4 x вес, кг) + (4.8 х рост, см) – (5.7 х возраст, лет)
// для женщин: BMR = 447.6 + (9.2 x вес, кг) + (3.1 х рост, cм) – (4.3 х возраст, лет)
// Коэффициенты активности при расчете нормы калорий(прописан в data-атрибутах):
//       Минимальный уровень активности — 1.2
// Низкий уровень активности — 1.375
// Средний уровень активности — 1.55
// Высокий уровень — 1.725
// Очень высокий —  1.9

// Событие: input
// Событие input срабатывает каждый раз при изменении значения.
// В отличие от событий клавиатуры, оно работает при любых изменениях значений, даже если они не связаны с 
// клавиатурными действиями: вставка с помощью мыши или распознавание речи при диктовке текста.
// Если мы хотим обрабатывать каждое изменение в <input>, то это событие является лучшим выбором.

// Конструкция "switch"
// Конструкция switch заменяет собой сразу несколько if и имеет один или более блок case и необ-й блок default.
// switch(x) {
//     case 'value1':  // if (x === 'value1')
//       [break]
//     case 'value2':  [break]
//     default: [break]
// }

// Math.round()
// Метод Math.round() возвращает число, округлённое к ближайшему целому.



// Команда запуска JSON-Server в терминале VS-code на Windows 10: npx json-server db.json
// npm install webpack webpack-cli --save-dev - команда по установке webpack!
// webpack.config.js - это наш конфигурац-й файл
// Далее выполним: npx webpack
