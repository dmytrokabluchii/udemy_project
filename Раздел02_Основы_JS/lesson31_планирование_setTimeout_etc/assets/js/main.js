 "use strict";

// Планирование: setTimeout и setInterval, отмена через clearTimeout

// setTimeout позволяет вызвать функцию один раз через определённый интервал времени
// в примере ниже через 2 сек, т.к. 2000мс это 2 сек
function sayHi() {
    // console.log('Привет');
    alert('Привет');
}
// setTimeout(sayHi, 2000);
// можно также сделать и так, если первый аргумент является строкой, то JS создаст из неё функцию
setTimeout("alert('Привет чувак')", 1000);
// Но использование строк не рекомендуется. Вместо этого используйте функции
setTimeout(() => alert('Привет чувак 2'), 2500);

// пример с аргументами:
function sayHi2(phrase, who) {
    alert( phrase + ', ' + who );
}
setTimeout(sayHi2, 5000, "Привет", "Дима"); // Привет, Дима

// clearTimeout - Отмена вызова фун-и
// В коде ниже планируем вызов функции и затем отменяем его (просто передумали). В результате ничего не происходит
let timerId = setTimeout(() => alert("ничего не происходит"), 1200);
// alert(timerId);         // идентификатор таймера
clearTimeout(timerId);  // отменяет вызов фун-и
alert(timerId);         // не сработает уже
// Как мы видим из вывода alert, в браузере идент-м таймера является число. В других средах это может быть что-то ещё


// setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.
// Метод setInterval имеет такой же синтаксис как setTimeout
// Следующий пример выводит сообщение каждые 2 секунды. Через 5 секунд вывод прекращается:
let timerId2 = setInterval(() => alert('tick'), 2000);   // повторить с интервалом 2 секунды
// остановить вывод через 5 секунд
setTimeout(() => { clearInterval(timerId2); alert('stop'); }, 5000);

// Вложенный setTimeout
// Есть два способа запускать что-то регулярно. 1-й setInterval. Другим является вложенный setTimeout. Например вместо:
// let timerId = setInterval(() => alert('tick'), 2000);
// Метод setTimeout ниже планирует следующий вызов прямо после окончания текущего
let timerId3 = setTimeout(function tick() {
    alert('tick');
    timerId3 = setTimeout(tick, 2000); // (*)
}, 2000);
// Вложенный setTimeout – более гибкий метод, чем setInterval. 
// С его помощью последующий вызов может быть задан по-разному в зависимости от результатов предыдущего.
// Т.е. Вложенный setTimeout позволяет задать задержку между выполнениями более точно, чем setInterval.
