 "use strict";

// Lesson 33 Массивы и псевдомассивы
const arr = [1, 2, 3, 6, 8, 'Dima'];
// узнать содержание массива
console.log(arr);
// узнаем длину массива .length
console.log(arr.length);   // 5

// нюансы при работе с .length
const arrN = [1, 2, 10, 'Dima'];
arrN[99] = 0;
console.log(arrN.length);   // 100
console.log(arrN);          // [ 1, 2, 10, 'Dima', <95 empty items>, 0 ]

// узнаём значение элемента в массиве по его позиции в массиве, начинается с 0 
console.log(arr[0]);   // 1
console.log(arr[5]);   // Dima
// узнаём значение элемента в многомерном массиве 
let arrManyLevel = [
    234,
    [2, 27, 'Nika']
];
console.log(arrManyLevel[1][2]);   // Nika


// методы массивов
const arr2 = [1, 2, 3, 6, 8, 'Dima'];

// .pop() удаляет последний елемент в массиве
arr2.pop();
console.log(arr2);   // [ 1, 2, 3, 6, 8 ]

// .push() - добавляет элемент в конец массива
arr2.push(129);
console.log(arr2);   // [1, 2, 3, 6, 8, 'Dima', 129];

// Метод shift() удаляет первый элемент из массива и возвращает его значение. Этот метод изменяет длину массива.
// Этот метод испол-ся редко т.к. изменение длины массива может навредить
arr2.shift();
console.log(arr2); 
// Метод unshift() добавляет один или более элементов в начало массива и возвращает новую длину массива.


// Методы перебора массива
const arr3 = [1, 2, 3, 6, 8, 'Dima'];

// цикл for в массиве с св-в length
for(let i = 0; i < arr3.length; i++) {
    console.log(arr3[i]);
}

// цикл for...of, где внутри условия цикла мы созд перем-ю, а в консоль выводим ее имя
// результат будет такой же как и в цикле выше!
for (let value of arr3) {
    console.log(value);
}

// forEach() - самый популярный метод перебора массивов
// Он принимает в себя callback фун-ю, аргументы которой
// item - тот елемент что мы перебираем / i - наш номер по порядку / arr3 - наш массив
arr3.forEach(function(item, i, arr3) {
    // и внутри мы можем делать необходимые для нас нанипуляции
    console.log(`${i}: ${item} внутри массива ${arr3}`);
});
 
// Метод map() создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.
let arr4 = [3, '11', 'Hello', '896', 'Dimas'];
let rezM = arr4.map(function(item, i, arr4) {
    return item[0];
});
console.log(rezM);     //   [ undefined, '1', 'H', '8', 'D' ]

const numbers = [1, 4, 9];
// Метод Math.sqrt() возвращает квадратный корень числа
const roots = numbers.map(Math.sqrt);
console.log(roots);      // [ 1, 2, 3 ]
console.log(Math.sqrt(12));   // 3.4641016151377544

// Метод split() разбивает объект String на массив строк путём разделения строки указанной подстрокой.
// т.е. он преоб-т строку в массив по заданному разделителю
// const str = prompt('','');
const str = 'Kolja, Dima, Ivan';
const names = str.split(', ');
console.log(names);   //  [ 'Kolja', 'Dima', 'Ivan' ]
const names2 = str.split();
console.log(names2);  // [ 'Kolja, Dima, Ivan' ]

// Метод join() объединяет все элементы массива (или массивоподобного объекта) в строку.
console.log(names.join('; '));  // Kolja; Dima; Ivan

// Метод sort() на месте сортирует элементы массива и возвращает отсортированный массив.
// и если у нас строки он отсорт-т их по алфавиту
console.log(names.sort());   // [ 'Dima', 'Ivan', 'Kolja' ]

const arrSortNumber = [23, 4, 12, 78, 9, 18, 265];
console.log(arrSortNumber.sort());   // [12, 18, 23, 265, 4, 78, 9]
// и чтобы этот метов нам правильно отсортировал массив цифр мы испол-м внутри него след-ю callback функцию:
// которая будет испол-ть внутри себя "алгоритм быстрой сортировки"
const arrSortNumber2 = [23, 4, 12, 78, 9, 18, 265];
arrSortNumber2.sort(compareNum);
console.log(arrSortNumber2);   // [4, 9, 12, 18, 23, 78, 295]
function compareNum(a, b) {
    return a - b;
}

// Метод reverse() меняет порядок следования элементов массива. Первый элемент стан-ся последним, а посл-й — первым.
const arr56 = ['one', 'two'];
console.log(arr56.reverse());   // [ 'two', 'one' ]

// Метод concat() возвращает новый массив, состоящий из массива, на котором он был вызван, 
// соед-го с другими массивами и/или значениями, переданными в качестве аргументов. Т.е. метод соед. 2 массива в один!
const array1 = ['a', 'b', 'c'];
const array2 = ['d', 'e', 'f'];
const array3 = array1.concat(array2);
console.log(array3);  // [ 'a', 'b', 'c', 'd', 'e', 'f' ]




// Задача: Создайте массив с элементами 'a', 'b', 'c', 'd'. Выведите с его помощью на экран строку 'a+b+c+d'.
let arr78 = ['a', 'b', 'c', 'd'];
console.log(arr78.join('+'));    // a+b+c+d
// Создайте массив с элементами 1, 2 и 3. Выведите на экран сумму этих элементов.
let arr79 = [1, 2, 3];
console.log(arr79[0] + arr79[1] + arr79[2]);   // 6
// Создайте массив с элементами 2, 5, 3, 9. Умножьте первый элемент массива на второй, а третий элемент на четвертый. 
// Результаты сложите, присвойте переменной result. Выведите на экран значение этой переменной.
let arr80 = [2, 5, 3, 9];
let resultArr80 = (arr80[0] * arr80[1]) + (arr80[2] * arr80[3]);
console.log(resultArr80);   // 37


let heroes = [
    {name: 'Batman', franchise: 'DC'},
    {name: 'Ironman', franchise: 'Marvel'},
    {name: 'Thor', franchise: 'Marvel'},
    {name: 'Superman', franchise: 'DC'}
];

let marvelHeroes =  heroes.filter(function(hero) {
    return hero.franchise == 'Marvel';
});
console.log(marvelHeroes);

let heroes2 = [
    ['Batman', 'DC'],
    ['Ironman', 'Marvel'],
    ['Thor', 'Marvel'],
    ['Superman', 'DC']
];
// console.log(heroes2[0]);

let marvelHeroes2 =  heroes2.filter(function(hero) {
    return hero[0] === 'Superman';
    // return hero[1] === 'Marvel';
});
console.log(marvelHeroes2);      // ['Superman', 'DC']


// Упрощение вложенных массивов
let arr333 = [1, 2, [3, 4, [5, 6]]];
arr333.flat(2);
// console.log(arr333);
// Метод flat удаляет пустые слоты из массива:
let arr444 = [1, 2, , 4, 5];
arr444.flat();               // [1, 2, 4, 5]




//                                              Шпаргалка по методам массива:

// ! Для добавления/удаления элементов:
// - push (...items) – добавляет элементы в конец,
// - pop() – извлекает элемент с конца,
// - shift() – извлекает элемент с начала,
// - unshift(...items) – добавляет элементы в начало.
// - splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
// - slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
// - concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из 
// items является массивом, тогда берутся его элементы.

// Для поиска среди элементов:
// - indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
// - includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
// - find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию 
// возвращается true.
// - findIndex похож на find, но возвращает индекс вместо значения.

// ! Для перебора элементов:
// - forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.

// ! Для преобразования массива:
// - map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
// - sort(func) – сортирует массив «на месте», а потом возвращает его.
// - reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
// - split/join – преобразует строку в массив и обратно.
// - reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая 
// промежуточный результат между вызовами.

// Дополнительно:
// - Array.isArray(arr) проверяет, является ли arr массивом.
// Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.
// Изученных нами методов достаточно в 99% случаев, но существуют и другие.

// .flat()
// Метод flat() возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно "подняты" 
// на указанный уровень depth.
// Метод flat удаляет пустые слоты из массива: