// Lesson 47 Рекурсия
// Рекурсия это когда функция вызывает сама себя.

// Классический пример функции рекурсивного вычисления факториала:
function factorial(n) {
    if ((n === 0) || (n === 1)) {
        return 1;
    }else{
        return (n * factorial(n - 1));
    }
}
// factorial(5);
console.log(factorial(5));   // 120

// кдасичес-й пример функ-и в степени. Рассмотрим два способа её реализации.
// 1. Итеративный способ: цикл for:
function pow(x, n) {
    let result = 1;
    for ( let i = 0; i < n; i++) {
         // умножаем result на x n раз в цикле
        result *= x;
    }
    return result;
}
pow(2, 1);  // 2
pow(2, 2);  // 4
pow(2, 3);  // 8
pow(2, 4);  // 16

// 2. Рекурсивный способ: упрощение задачи и вызов функцией самой себя:
function powRecursion(x, n) {
    if (n === 1) {
        return x;
    }else{
        return x * powRecursion(x, n - 1);
    }
}
powRecursion(2, 1);  // 2
powRecursion(2, 2);  // 4
powRecursion(2, 3);  // 8
powRecursion(2, 4);  // 16


// Метод  Object.values() возвращает массив значений перечисляемых свойств объекта в том же порядке что и цикл for...in. 
// Разница между циклом и методом в том, что цикл перечисляет свойства и из цепочки прототипов.
const object1 = {
    a: 'somestring',
    b: 42,
    c: false
  };
  
console.log(Object.values(object1));   // ["somestring", 42, false]

// Метод Array.isArray() возвращает true, если объект является массивом и false, если он массивом не является.
// Синтаксис: Array.isArray(obj) где obj это - Объект для проверки.
const someArray = ['Dima', 'Kab', 37];
const someObj = {name: 'Dima'};
console.log(Array.isArray(someArray));  // true
console.log(Array.isArray(someObj));    // false

// напоминаем что в массивах у нас раб-т св-во .length, т.е мы можем узнать кол-во элем-в в массиве
console.log(someArray.length);   // 3
console.log(someObj.length);     // undefined

// а теперь посмотрим на пример реал-ции сбора статис-ки с данных в объекте, такое мы часто будем делать в будущем!
// т.е. это станд. пример реал-ции перебора струк-ры данных

// имеем такой обьект с студентами по курсам, их именами и их прогрессом по курсам
let students = {
    js: [{
        name:'John',
        progress: 100
    }, {
        name:'Ivan',
        progress: 60
    }],

    html: {
        basic: [{
            name:'Peter',
            progress: 20
        }, {
            name:'Ann',
            progress: 18
        }],

        pro: [{
            name:'Sam',
            progress: 10
        }],
        // добавим еще одно св-во в наш объект students
        semi: {
            students: [{
                name:'Test',
                progress: 100
            }]
        }
    }
};

// 1-й вариант фун-и через итерацию
function getTotalProgressByItreration(data) {
    let total = 0;
    let students = 0;
    // получаем знач-е обьекта
    for (let course of Object.values(data)) {
        // если это массив то выпол-м эти операции
        if (Array.isArray(course)) {
            // получим общее кол-во студентов
            students += course.length;
            for (let i = 0; i < course.length; i++) {
                total += course[i].progress;
            }
            // а если это объект то эти операции
        } else {
            for (let subCourse of Object.values(course)) {
                students += subCourse.length;
                for (let i = 0; i < subCourse.length; i++) {
                    total += subCourse[i].progress;
                }
            }
        }   
    }
    return total / students;
}
// выведем в консоль результат этой фун-и
// console.log(getTotalProgressByItreration(students));   // 41.6 - это и будет сред. знач-е прогресса по всем студентам   


// перепишем теперь пример выше используя рекурсию!
function getTotalProgressByRecursion(data) {
    // внутри этого условия посчитаем наш общий прогресс, это будет наша база рекурсии!
    // если это массив то выпол-м эти операции
    if (Array.isArray(data)) {
        let total = 0;
        // теперь при помощи цикла склад-м весь прогресс студ-в в одну перем-ю total
        for (let i = 0; i < data.length; i++) {
            total += data[i].progress;
        }
        // нам нужно вернуть сразу 2 знач-я из этой фун-и, и самый простой способ это вернуть массив из 2-х значений
        // т.е. нам нужно вернуть не только общий прогресс студ-в но и их общее кол-во
        return [total, data.length];
        // и если обьект что приходит это не массив, то мы попад-м в блок кода ниже
    } else {
        // записываем просто массив  с числами в перем-ю и далее мы их вернем в работу
        let total = [0, 0];
        // испол-м тут метод перебора в обьекте for of, где нам нужно получ-ть лиш значения св-в в объекте, т.е. Object.values
        for (let subData of Object.values(data)) {
            // здесь мы запишем самый важный момент в во всей рекурсии, т.к. у нас есть влож-е данные то мы должны
            // саму же фун-ю и запустить на этих же данных, т.е мы распрост-м действие фун-и на внут. стр-ры данных в объекте
            // мы точно знаем что у нас будет масссив с данными
            const subDataArr = getTotalProgressByRecursion(subData);
            // т.е в массиве subDataArr у нас каждый раз будет запус-ся рекурсия и она внутри себя будет запускаться до тех пор
            // пока она не дойдет до базы, т.е. не наткнется на конеч-й массив со всеми студентами кот-е зарег-ны где-то
            // и когда мы запус-м рукурсию она не всегда может наткнуться на массив. 
            // И когда мы получили наш массив данных(subDataArr), т.к. мы переб-м циклом данные, нас интер-т конеч-я перем. total
            // где [0] индекс это у нас полч-я общее знач-е всего прогресса
            total[0] += subDataArr[0];
            total[1] += subDataArr[1];
        }
        // и когда у нас сработал блок кода else мы в конеч-м итоге вернем массив с данными и его потом будем испол-ть
        return total;
        // В итоге каждая фун-я будет возвр-ть нам массив данных
    }
}
// наша перем-я result будет резул-т вызова этой фун-и с объектом студентов.
// в резул-те мы получ-м массив кот-й будет содер-ть массив с 2-мя данными [общее кол-во прогресса, общее кол-во студ-в]
const result = getTotalProgressByRecursion(students);
// И когда мы получим этот результат, нам нужно будет получить резул-т их деления, т.е. мы делим
// общий прогресс со всех студен-в result[0] делим на общее кол-во студ-в result[1]
console.log(result[0] / result[1]);   // 41.6 , т.е функ-я работает точно так же как и пред-я!


// добавим еще одно св-во в наш объект students, это св-во semi, тем самым мы изменили стр-ру объекта
// и если мы теперь запустим нашу 1-ю фун-ю(через итерацию которая), то она теперь не сраб-т, т.к измен-сь струк-ра
// т.к. она расчитана на опред-ю структуру данных, т.е она натк-ся на добав-й обэект и полом-ся
// а вот если мы запустим наш 2-й вариант фун-и с рекурсией, то ничего не сломается и мы получим резул-т
// и теперь наша фун-я будет работать с любой вложен-ю сколь бы мы не добавляли структур!
console.log(result[0] / result[1]);         // 51.333333333333336

