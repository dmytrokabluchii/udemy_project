// Lesson 45. События и их обработчики

// 2-й способ назначить обработчик события, испол-ть св-во DOM-дерева,  испол-ся не часто в соврем. JS
// данный вид обраб-ка событий мы не сможем удалить просле срабат-я!
// Сначала вешаем оработч-к события на наш элемент
const btns = document.querySelectorAll('button');
// далее идет способ назначения, св-во DOM дерева событ-е .onclick
// где в качестве знач-я будет функ-я, которая выполнится строго посде клика
// btns[0].onclick = function() {
//     alert('Hello Dima');
// };
// например при повт-м назначении события сработ-т лиш последнее
// btns[0].onclick = function() {
//     alert('Hello Friend');
// };

// правильно будет испол-ть методы .addEventListener() и если удалить нужно, то .removeEventListener()
// Метод EventTarget.addEventListener() регистрирует определённый обработчик события, вызванного на EventTarget.
// EventTarget может быть Element, Document, Window, или любым другим объектом, поддер-м события (таким как XMLHttpRequest)
// И этим методом можно назн-ть действия сразу на несколько событий!
// 'click'- это 1-й арг-т, это название нашего события, а 2-й арг-т это callback фун-я, кот-я запус-ся после сраб-я соб-я 'click'
btns[1].addEventListener('click', () => {
    alert('Hi Dimon!');
});
btns[1].addEventListener('click', () => {
    alert('Hi Nika!');
});
// эффект при наведении мышки на элемент
// btns[1].addEventListener('mouseenter', () => {
//     console.log('It is Hover!');
// });

// Обьект Event, представляет собой любое событие, которое происходит в DOM; некоторые из них генерируемые пользователем 
// (клик мышью или нажатие клавиши на клавиатуре), а некоторые - генерируемые API (события, обозначающие завершение 
// процесса анимации, приостановка видео и т.д.)
// Этот обьект перед-ся в нашу callback фун-ю в кач-ве 1-го аргум-та! Если арг-в будет неск-ко их мы перед-м через ( ,)
// название у событ-я может быть любым, но зачастую его назыв-т или просто 'event' или 'e'
btns[1].addEventListener('mouseenter', (e) => {
    console.log(e);  // MouseEvent {isTrusted: true, screenX: -1654, …}
    //     console.log('It is Hover!');
});
//  при наведении на кнопку в консоли мы увидим объект кот-ый описывает что произошло с элементом
// и эти св-ва внутри обьекта мы часто будем испол-ть!
// например чтобы получить доспуп к элементу, мы в консоле просто доб-м к событию 'e' .target, при этом св-ва могут быть разные!
// btns[1].addEventListener('mouseenter', (e) => {
//     console.log(e.target);   // <button>Нажми меня</button>
// });
// и теперь с этим элиментоммы можем сделать все что захочем, напр. изм-ть цвет, удалить и тд
// btns[1].addEventListener('mouseenter', (e) => {
//     console.log(e.target);  
//     e.target.remove();
// });

// Если нам нужно что бы событие сработало всего 1 раз и потом удалилось, испол-м .removeEventListener() и такую стр-ру
let i = 0;
const deleteElement = (e) => {
    console.log(e.target);  
    i++;
    if (i == 1) {
        // т.е. когда i = 1, т.е. мы нажали на кнопку 1 раз, сраб-т удаление этого обработчика с нашей кнопки
        btns[0].removeEventListener('click', deleteElement);
    }
};
// т.е. когда у нас сраб-т 'click' то выпол-ся фун-я deleteElement
btns[0].addEventListener('click', deleteElement);

// всплытие событий пример на 15:40 видео
// Event.currentTarget - Определяет элемент, в котором в данный момент обрабатывается событие, при движении события внутри DOM
// event.currentTarget используется, когда один и тот же обработчик события присваивается нескольким элементам.

// Event.target
// Свойство target интерфейса Event является ссылкой на объект, который был инициатором события. 
// Он отличается от Event.currentTarget, если обработчик события вызывается во время всплытия (bubbling) или захвата события

// Свойства
// Event.bubbles - Логическое значение, указывающее, всплыло ли событие вверх по DOM или нет
// Возвращает булево значение true, если событие является всплывающим внутри DOM.

// Event.stopPropagation() - Прекращает дальнейшую передачу текущего события.

// Метод preventDefault () - помогает отменить станд. поведение в браузере
const link = document.querySelector('a');
link.addEventListener('click', (event) => {
    // этот метод всегда ставится вначале, т.к. он отменяет в этом месте станд. действия браузера
    event.preventDefault();
    console.log(event.target);
});

// чтобы применить одну функцию сразу на нескл. элементов испол-м цикл forEach
// т.е мы берем и один и тот же обраб-к событ-й навешиваем на неск-ко элементов
// btns.forEach(btn => {
//     btn.addEventListener('click', deleteElement);
// });

// У метода .addEventListener() есть еще возможности доп. опций, напомним его синтаксис:
// target.addEventListener(type, listener[, options]);
// Объект options, который определяет характеристики объекта, прослушивающего событие. Один из доступных вариантов это:
// св-во once: Boolean указывает, может опреде-ть что-бы обработчик был вызван не более одного раза после добавления. 
// Если true, то обработчик автоматически удаляется при вызове. Т.е. этот способ может отчасти заменяет метод .removeEventListener
btns.forEach(btn => {
    // т.е. в объект мы просто передаём св-во once со значением true
    btn.addEventListener('click', deleteElement, {once: true});
});
//  про все опции можно узнать на MDN