'use strict';
// Lesson 86. Promise (ES6)

// Объект Promise используется для отложенных и асинхронных вычислений.
// Помните, что промисы лежат в основе async/await и их понимание, можно сказать, что обязательно для работы с асинхронным JS
// Синтаксис создания Promise:
// let promise = new Promise(function(resolve, reject) {
//    функция-исполнитель (executor)
//    код фун-и
// });

// у промиса есть 3 состояния. Это:
// 1. Промис в состоянии ожидания (pending). Когда вы не знаете, получите ли вы мобильный телефон к следующей неделе или нет.
// 2. Промис решен (resolved). Вам реально купят новый телефон.
// 3. Промис отклонен (rejected). Вы не получили новый мобильный телефон, так как всё-таки, мама была не в настроении.


// Эдеми примеры. 
// Обычный пример синхронного кода, который выполнится сразу
console.log('Запрос данных...');

// Строим дерево callback-ов, которое имеет определ-й порядор действия и асинхронность
// setTimeout(() => {
//     console.log('Подготовка данных');
//     // Имулируем как будто мы получили эти данные от сервера
//     const product = {
//         name: 'TV',
//         price: 2000
//     };
//     // И когда мы уже получили данные свыше мы хотим с ними что-то сделать и сделать это асинхронно(т.е. не сразу)
//     setTimeout( () => {
//         product.status = 'order';
//         console.log(product);
//     }, 2000);
// }, 2000);


// И что-бы мы не попадали в callback-help нам и понадобятся промисы
// Когда мы испол-м промисы то эти 2 аргум-та (resolve, reject) обознач-т фун-и, которые мы в будущем можем передавать
// Фун-я resolve - означает что код выпол-ся правильно, т.е. "обещание" выпол-сь как мы ожидали(т.е правильно)
// Фун-я reject - означает что код выпол-ся неверно, возможно с "ошибкой", т.е. что-то пошло не так
// Создадим промис(обещание) new Promise() и поместим его в перем-ю reg
// Когды мы его созд-м мы понимаем что оно может завер-ся как полож-но так и отриц-но, например мы посыл-м запрос на сервер
// и ждем, при этом не знаем как он ответит
const req = new Promise( (resolve, reject) => {
    // Ниже идет имитация асинхр-го кода, как будто данные от сервера пришли к нам, через 2 сек
    setTimeout(() => {
        console.log('Подготовка данных');
        // Имулируем как будто мы получили эти данные от сервера
        const product = {
            name: 'TV',
            price: 2000
        };
        // Если все прошло успешно то мы вызываем фун-ю resolve
        resolve(product);
        // Если что-то пошло не по плану, то reject
    }, 2000);
});
// Промисы имеют след-е строенные методы, это then(), catch() и finally()
// then() - это метод кот-й выпол-ся на промисе в случае полож. исхода, т.е. внутри себя он прнимает фун-я resolve()
// Она еще нигде не объявлена, а будет перед-ся просто как объект и этот аргум-т мы как раз и помещаем в () в фун-ю then()
// сюда (product) приходят данные допустим от сервера
req.then( (product) => {
    // Создаем новый промис и сразу возвращаем его, внутри он будет выпол-ть асинх-ю операцию
    return new Promise( (resolve, reject) => { 
        setTimeout( () => {
            product.status = 'order';
            resolve(product);
            // фун-я reject() запус-ся если произошла ошибка и чтобы ее обраб-ть есть спец. метод catch(), он нах-ся в конце
            // reject();
        }, 2000);
    });
    // И что-бы использовать промис выше... в data - в этот аргумент прийдут какие-то данные
}).then(data => {
    // также из этих колбек фун-й мы можем возвр-ть не только промисы, модифиц-м объект data
    data.modify = true;
    return data;
    // Преимущ-во промисов в том что мы можем возвр-ть их по цепочке, когда выпол. одна асинх-я операция мы выпол-м след-ю и тд
    // ниже обраб-м асинх-е данные по цепочке. Таким образом мы получаем послед-ть нашего кода
}).then(data => {
    console.log(data);    // { name: 'TV', price: 2000, status: 'order', modify: true }
    // действие с методом catch() выпол-ся если произ-ла ошибка
}).catch( () => {
    // console.error() - Выводит сообщение об ошибке в веб-консоль.
    console.error('Произошла ошибка');
    // метод .finally() испол-ся в самом конце, после catch() и тд, и позволяет выполнять действия в любом исходе промиса
    // т.е. действия которые должны происходить всегда. Например мы так можем очищать форму полей после отправки данных на сервер
}).finally( () => {
    console.log('Finally');
});


// Рассмотрим методы Promise.all(), 
const test = time => {
    return new Promise(resolve => {
        setTimeout( () => resolve(), time);
    });
};
// test(1000).then(() => console.log('1000 ms'));
// test(2000).then(() => console.log('2000 ms'));
// метод all() принимает во внутрь себя массив с промисами(внутри у нас нах-ся 2 фун-и с промисами кот-е вернут результат)
// команда Promise.all нужна для того что-бы мы убедились что все наши промисы уже выпол-сь
// Таким образом мы можем делать несколько запросов(например получить фото) на разные сервера и эти сервера могут по разному 
// отвечать нам и через разные промежутки времени, но нам нужно что бы все фото показались одновременно на сайте,
// т.е. нам нужно подождать загрузки всех промисов и только потом что-то делать, 
// т.е. метод all() ждет окончания загрузки всех промисов и только потом что-то делает
Promise.all([test(1000), test(2000)]).then( () => {
    console.log('All');   // All  - это значит что выпол-сь оба промиса
});
// метод race() начинает работу только тогда когда самый 1-й промис уже отработал
Promise.race([test(1000), test(2000)]).then( () => {
    console.log('Race');   // Race  - это значит что выпол-сь 1-й промис
});



// Это аналогия из реальной жизни для ситуаций, с которыми мы часто сталкиваемся в программировании:
// Есть «создающий» код, который делает что-то, что занимает время. Например, загружает данные по сети. У нас это – «певец».
// Есть «потребляющий» код, который хочет получить результат «создающего» кода, когда он будет готов. Он может быть необходим 
// более чем одной функции. Это – «фанаты».
//      Promise (по англ. promise, будем называть такой объект «промис») – это специальный объект в JavaScript, который связывает 
// «создающий» и «потребляющий» коды вместе. В терминах нашей аналогии – это «список для подписки». «Создающий» код может 
// выполняться сколько потребуется, чтобы получить результат, а промис делает результат доступным для кода, который подписан 
// на него, когда результат готов.
//      Аналогия не совсем точна, потому что объект Promise в JavaScript гораздо сложнее простого списка подписок: он обладает 
// дополнительными возможностями и ограничениями. Но для начала и такая аналогия хороша.
//      Синтаксис создания Promise:
// let promise = new Promise(function(resolve, reject) {
//    функция-исполнитель (executor)
//    "певец"
// });
//      Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запус-ся 
// автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат. В терминах нашей аналогии: 
// исполнитель – это «певец».
//      Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript. Наш код – только внутри исполнителя.
// Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:
// resolve(value) — если работа завершилась успешно, с результатом value.
// reject(error) — если произошла ошибка, error – объект ошибки.
// Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать resolve или reject.

// Потребители: then, catch, finally
// Объект Promise служит связующим звеном между исполнителем («создающим» кодом или «певцом») и функциями-потребителями 
// («фанатами»), которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) 
// с помощью методов .then, .catch и .finally.

// then
// Наиболее важный и фундаментальный метод – .then. Синтаксис:
// promise.then(
//   function(result) { /* обработает успешное выполнение */ },
//   function(error) { /* обработает ошибку */ }
// );
// Если мы заинтересованы только в результате успешного выполнения задачи, то в then можно передать только одну функцию
// let promise = new Promise(resolve => {
//     setTimeout(() => resolve("done!"), 1000);
//   });
// promise.then(alert);     // выведет "done!" спустя одну секунду
// Подробнее на: https://learn.javascript.ru/promise-basics

// catch()
// Метод catch() возвращает промис (Promise() и работает только в случае отклонения промиса(например в случае ошибки). 
// Ведёт себя аналогично вызову Promise.prototype.then(undefined, onRejected).

// finally()
// Метод finally() возвращает Promise. Когда промис был выполнен, вне зависимости успешно или с ошибкой, указанная функция 
// будет выполнена. Это даёт возможность запустить один раз определённый участок кода, который должен выполниться вне зависимости 
// от того, с каким результатом выполнился Promise.
// Например мы так можем очищать форму полей после отправки данных на сервер
// Это позволяет вам избавиться от дубликации кода в обработчиках then() и catch().

// Ознакомились с пятью статическими методами класса Promise:
// Promise.all(promises) – ожидает выполнения всех промисов и возвращает массив с результатами. Если любой из указанных промисов 
// вернёт ошибку, то результатом работы Promise.all будет эта ошибка, результаты остальных промисов будут игнорироваться.
// Promise.allSettled(promises) (добавлен недавно) – ждёт, пока все промисы завершатся и возвращает их результаты в 
// виде массива с объектами, у каждого объекта два свойства:
// state: "fulfilled", если выполнен успешно или "rejected", если ошибка,
// value – результат, если успешно или reason – ошибка, если нет.
// Promise.race(promises) – ожидает первый выполненный промис, который становится его результатом, остальные игнорируются.
// Promise.resolve(value) – возвращает успешно выполнившийся промис с результатом value.
// Promise.reject(error) – возвращает промис с ошибкой error.
// Из всех перечисленных методов, самый часто используемый – это, пожалуй, Promise.all.


// console.error()
// Выводит сообщение об ошибке в веб-консоль.
