'use strict';
// Lesson 87. Fetch API

// API - это набор данных и возможностей которые предоставляет нам готовое решение. Мы уже слышали про 
// DOM API - это все методы кот-е позволяют нам работать с элементами на стр-це, и эти возм-ти ужеь встр-ны в браузер
// Есть также API от производителей прогр-го обеспечения, например google maps api, которое позволяет работать с картами и тд
// Т.е. API предоставляет нам готовые методы и св-ва которые мы можем испол-ть у себя в работе!

// Fetch API - это встр-е в браузер технология, она современная и позволяет нам общаться с сервером и построена она на промисах
// Рассмотрим самой простой запрос с get и получением данных и далее как-то их обработаем

// Базовый синтаксис метода fetch:
// let promise = fetch(url, [options])
// url – URL для отправки запроса. options – дополнительные параметры: метод, заголовки и так далее.
// Без options это простой GET-запрос, скачивающий содержимое по адресу url.

// Пример с сайта https://jsonplaceholder.typicode.com/
// Метод fetch испол-т промисы и с URL адреса в () верн-ся промис и далее мы его соот. сможем обраб-ть цепочкой и методом .then
fetch('https://jsonplaceholder.typicode.com/todos/1')
    // в response у нас находит-ся ответ и получаем мы его в формате json и чтобы его далее испол-ть в клиенте мы можем 
    // трасфор-ть его в обычный объект и у метода fetch есть для этого встр-е возм-ти(и это не метод parse кот-й мы ранее юзали),
    // метод .json(), но здесь есть особ-ть, команда response.json() возвр-т нам промис, что-бы мы могли постр-ть далее цепочку
    .then(response => response.json())
    .then(json => console.log(json));
    // в рез-те мы получим такой объект от сервера - {userId: 1, id: 1, title: 'delectus aut autem', completed: false}

// Что-бы делать POST-запросы поменяем стр-ру выше, вст-м объект с настр-ми которые мы будем задавать 
// этот объект имеет много свойств, но самыми обяз-ми явл-ся 2 - method и body
// теперь нужно выбрать URL куда это отпра-ть, адрес выберем в меню Routes сайта jsonplaceholder (.../posts)
// т.е. мы как бы имулируем отпр-ку post-запрос на сервер, кот-й потом будет обраб-ся на back-end
fetch('https://jsonplaceholder.typicode.com/posts', {
    method: "POST",
    // в body мы можем поместить как строку так и объект
    body: JSON.stringify({name: 'Dima'}),
    // выше мы имеем объект кот-й сразу прев-ся в JSON-формат и мы отпр-м его испол-я метод fetch
    // не забываем также указывать заголовки(headers) что-бы знать какой контент мы отпр-м, не забываем что
    // headers идут во множ. числе, это значит что далее будет идти объект с уже знакомой струк-й
    headers: {
        'Content-type': 'application/json'
    }
    // json выше уже настроен
})
// и в консоле мы увидем такой объект - {name: 'Dima', id: 101}
.then(response => response.json())
.then(json => console.log(json));







// API (аббр. от англ. Application Programming Interface — «программный интерфейс приложения») — описание способов 
// (набор классов, процедур, функций, структур или констант), которыми одна компьютерная программа может взаимодействовать 
// с другой программой. Обычно входит в описание какого-либо интернет-протокола (программного каркаса (фреймворка)[3] 
// или стандарта вызовов функций операционной системы[4]. Часто реализуется отдельной программной библиотекой или 
// сервисом операционной системы. Используется программистами при написании всевозможных приложений.
// Проще говоря, это набор компонентов, с помощью которых компьютерная программа (бот или же сайт) может взаимодействовать 
// с другой программой (API).
//      Назначение
// API (интерфейс прикладного программирования) упрощает процесс программирования при создании приложений, абстрагируя 
// базовую реализацию и предоставляя только объекты или действия, необходимые разработчику. Если графический интерфейс 
// для почтового клиента может предоставить пользователю кнопку, которая выполнит все шаги для выборки и выделения новых 
// писем, то API для ввода/вывода файлов может дать разработчику функцию, которая копирует файл из одного места в другое, 
// не требуя от разработчика понимания операций файловой системы, происходящих за кулисами.

//      Fetch API предоставляет интерфейс JavaScript для работы с запросами и ответами HTTP. Он также предоставляет глобальный 
// метод fetch() (en-US), который позволяет легко и логично получать ресурсы по сети асинхронно.
// Подобная функциональность ранее достигалась с помощью XMLHttpRequest. Fetch представляет собой лучшую альтернативу, 
// которая может быть легко использована другими технологиями, такими как Service Workers. Fetch также обеспечивает 
// единое логическое место для определения других связанных с HTTP понятий, такие как CORS и расширения для HTTP.
// Обратите внимание, fetch спецификация отличается от jQuery.ajax() в основном в двух пунктах:
// - !!! Promise возвращаемый вызовом fetch() не перейдёт в состояние "отклонено" из-за ответа HTTP, который считается ошибкой, 
// даже если ответ HTTP 404 или 500. Вместо этого, он будет выполнен нормально (с значением false в статусе ok ) 
// и будет отклонён только при сбое сети или если что-то помешало запросу выполниться.
// - По умолчанию, fetch не будет отправлять или получать cookie файлы с сервера, в результате чего запросы будут осуществляться 
// без проверки подлинности, что приведёт к неаутентифицированным запросам, если сайт полагается на проверку пользовательской 
// сессии (для отправки cookie файлов в аргументе init options должно быть задано значение свойства credentials отличное от 
// значения по умолчанию omit).
//      fetch()
// Есть несколько способов делать сетевые запросы и получать информацию с сервера.
// Метод fetch() Базовый синтаксис:
// let promise = fetch(url, [options])
// url – URL для отправки запроса.
// options – дополнительные параметры: метод, заголовки и так далее.
// Без options это простой GET-запрос, скачивающий содержимое по адресу url.
// Браузер сразу же начинает запрос и возвращает промис, который внешний код использует для получения результата.
//      Во-первых, promise выполняется с объектом встроенного класса Response в качестве результата, как только сервер 
// пришлёт заголовки ответа. На этом этапе мы можем проверить статус HTTP-запроса и определить, выполнился ли он успешно, 
// а также посмотреть заголовки, но пока без тела ответа.
// Промис завершается с ошибкой, если fetch не смог выполнить HTTP-запрос, например при ошибке сети или если нет такого сайта. 
// HTTP-статусы 404 и 500 не являются ошибкой. Мы можем увидеть HTTP-статус в свойствах ответа:
// status – код статуса HTTP-запроса, например 200.
// ok – логическое значение: будет true, если код HTTP-статуса в диапазоне 200-299.
// Например:
// let response = await fetch(url);
// if (response.ok) { // если HTTP-статус в диапазоне 200-299
//    получаем тело ответа (см. про этот метод ниже)
//   let json = await response.json();
// } else {
//   alert("Ошибка HTTP: " + response.status);
// }
//      Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.
// Response предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах:
// response.text() – читает ответ и возвращает как обычный текст,
// response.json() – декодирует ответ в формате JSON,
// response.formData() – возвращает ответ как объект FormData (разберём его в следующей главе),
// response.blob() – возвращает объект как Blob (бинарные данные с типом),
// response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),
// помимо этого, response.body – это объект ReadableStream, с помощью которого можно считывать тело запроса по частям. 
// Мы рассмотрим и такой пример несколько позже.
// Например, получим JSON-объект с последними коммитами из репозитория на GitHub:
// let url = 'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits';
// let response = await fetch(url);
// let commits = await response.json(); // читаем ответ в формате JSON
// alert(commits[0].author.login);

// https://jsonplaceholder.typicode.com/
// All HTTP methods are supported. You can use http or https for your requests.
// GET	/posts
// GET	/posts/1
// GET	/posts/1/comments
// GET	/comments?postId=1
// POST	/posts
// PUT	/posts/1
// PATCH	/posts/1
// DELETE	/posts/1
