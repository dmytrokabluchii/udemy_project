'use strict';
// Lesson 99-100. Геттеры и сеттеры (свойства объектов). Инкапсуляция
const persone = {
    name: 'Dima',
    age: 25,
    // Поработаем со св-в age в качестве геттере и сеттера.
    //  get нам нужен чтобы получать значение
    get userAge() {
        // далее работаем как с обычным методом. Вернем текущий возраст персонажа
        return this.age;
    },
    // set же нужен чтобы устанав-ть это значение. Если мы не устан-м сеттер то в дальнейшем не сможем присваивать знач-я!
    // далее в пару к нему мы можем установить сеттер, где приним-я фун-я userAge должна принимать в себя аргум-т ()
    set userAge(num) {
        // когда испол-я сеттер мы возьмем его возраст(this.age) и запишем туда знач-е кот-е будет передаваться из вне (num)
        this.age = num;

    }

};
// теперь при вызове userAge() мы будем получать текущий возраст персонажа. 
// Важно запомнит что геттер уже предполагает что внутри у нас уже есть какой-то функционал и он позволяет работать с этим методом
// как с обычным свов-в, после userAge мы уже можем () не ставить! Именно поэтому это и назыв-ся св-во-аксессор
// console.log(persone.userAge);   // 25
// если мы присвоим новое значение св-ву, то мы установим новый возраст польз-ля
console.log(persone.userAge = 37);     // 37
console.log(persone.userAge);          // 37


// Инкапсуляция - это защита от вмешательства пользователя!. Разберем ее на примере фун-и констр-ре
function User(name, age) {
    // далее сконстр-м новый объект
    this.name = name;
    // this.age = age;
    // применяем инкапсуляцию, заменим this.age на userAge кот-я принимает в себя тот пар-р что приходит при создании объекта
    // теперь к этой перем-й мы имеем доступ только изнутри
    let userAge = age;
    this.say = function() {
        console.log(`Name user: ${this.name}, Age: ${userAge}`);          // Name user: Nika, Age: 10
    };
    // созд-м фун-ю "геттер" для получ-я данных, этот метод будет как-бы отдавать значение
    this.getAge = function() {
        return userAge;
    };
    // а след-й "сеттер" изменять его
    this.setAge = function(age) {
        if (typeof age === 'number' && age > 0 && age < 110) {
            userAge = age;
        } else {
            console.log('Недопустимое значение!');
        }
    };
    // И теперь методы выше мы можем испол-ть в коде ниже
}
const dima = new User('Dima', 38);
// Получаем доступ к этим св-м
console.log(dima.name);
// получаем возраст испол-я созд-й выше метод getAge()
console.log(dima.getAge());
// Далее изменим его
dima.setAge(30);
dima.setAge(300);
console.log(dima.getAge());
// далее вызовем метом .say который покажет что за изменения есть у нас в объекте
dima.say();
// т.е. на данный момент в примере выше любой может вмешаться и поменять наши значения и такое поведение нам нужно изменить!

// В пример выше немного изменим синтаксис на классы
class User2 {
    constructor(name, age) {
        this.name = name;
        // Если в классе нам какое-то св-во нужно скрыть от пользователя испол-м синтаксис _age
        this._age = age;
    }
    // если перед surname мы допишем # это св-во станет приватным
    #surname = 'Kabluchii';
    // При таком синтаксисе(ниже) у нас есть возм-ть созд-ть приватные св-ва в классах, как это делается и др. язык прогр-я
    say = () => {
        // контекст вызова this будет всегда ссылат-ся на экземпляр этого объекта
        console.log(`Name user: ${this.name} ${this.#surname}, Age: ${this._age}`);         
    }
    // созд-м геттер для получ-я данных, этот метод будет как-бы отдавать значение
    get age() {
        return this._age;
    }
    // а след-й сеттер изменять его
    set age(age) {
        if (typeof age === 'number' && age > 0 && age < 110) {
            this._age = age;
        } else {
            console.log('Недопустимое значение!');
        }
    }
    // И теперь методы выше мы можем испол-ть в коде ниже
}
const dima2 = new User2('Dima', 38);
// через # мы не сможем обратится снаружи к приватному св-ву #surname. 
console.log(dima2.surname);
// далее вызовем метом .say который покажет что за изменения есть у нас в объекте
dima2.say();


// Д.З создадим класс с приватным свойством внутри
class User3 {
    constructor(name, surname, age) {
        this.name = name;
        this.surname = surname;
        // синтаксис _ если в классе нужно скрыть какое-то св-во от пользователя
        this._age = age;
    }
    // # перед свойством сделает его станет приватным
    #weight = 78;
    // След. синтаксис дает возм-ть созд-ть приватные св-ва в классах, как это делается и др. язык прогр-я
    say = () => {
        console.log(`Name user: ${this.name}, surname: ${this.surname}, age: ${this._age}, weight: ${this.#weight}`);         
    }               // Name user: Dima, surname: Kabl, age: 38, weight: 75
    // геттер и сеттер позволяют создать на вид обычное свойство, но работающее через функции.
    // часто они применяются соответственно для чтения приватных свойств и присвоения им новых значений
    // геттер для получения веса
    get weight() {
        return this.#weight;
    }
    // сеттер для установки веса
    set weight(weight) {
        if (typeof weight === 'number' && weight > 1 && weight < 210) {
            this.#weight = weight;
        } else {
            console.log(`${this.#weight} - Недопустимое значение веса!`);
        }
    }
}
const dima3 = new User3('Dima', 'Kabl', 38);
// меняем извне значение для приватного св-ва внутри объекта
dima3.weight = 75;
console.log(dima3.weight);    // 75
//  вызовем метом .say который покажет изменения в объекте
dima3.say();




// Свойства - геттеры и сеттеры
// Есть два типа свойств объекта.
// Первый тип это свойства-данные (data properties). Мы уже знаем, как работать с ними. Все свойства, которые мы использовали 
// до текущего момента, были свойствами-данными.
// Второй тип свойств мы ещё не рассматривали. Это свойства-аксессоры (accessor properties). По своей сути это функции, которые 
// используются для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта.

// Свойства-аксессоры представлены методами: «геттер» – для чтения и «сеттер» – для записи. 
// При литеральном объявлении объекта они обозначаются get и set:
/* let obj = {
    get propName() {
      // геттер, срабатывает при чтении obj.propName
    },
    set propName(value) {
      // сеттер, срабатывает при записи obj.propName = value
    }
}; */
// Геттер срабатывает, когда obj.propName читается, сеттер – когда значение присваивается.


// Инкапсуляция
// Инкапсуляция - это упаковка данных и функций в один компонент (например, класс) и послед-й контроль доступа к этому комп-ту, 
// создавая тем самым "чёрный ящик" из объекта. По этой причине, пользователю необходимо знать только интерфейс этого класса 
// (то есть данные и функции, предоставляемые для взаимодействия с классом извне), а не то, как он реализован внутри.
// Т.е. это защита от вмешательства пользователя!

// Инкапсуляция
// Инкапсуляция (encapsulation) - это механизм, который объединяет данные и код, манипулирующий зтими данными, а также защищает 
// и то, и другое от внешнего вмешательства или неправильного использования. В объектно-ориентированном программировании код 
// и данные могут быть объединены вместе; в этом случае говорят, что создаётся так называемый "чёрный ящик". Когда коды и 
// данные объединяются таким способом, создаётся объект (object). Другими словами, объект - это то, что поддерживает инкапсуляцию.
//     Внутри объекта коды и данные могут быть закрытыми (private). Закрытые коды или данные доступны только для других частей 
// этого объекта. Таким образом, закрытые коды и данные недоступны для тех частей программы, которые существуют вне объекта. 
// Если коды и данные являются открытыми, то, несмотря на то, что они заданы внутри объекта, они доступны и для 
// других частей программы.

// Приватные свойства и методы: https://itchief.ru/javascript/classes#private
// До этого мы создавали только публичные свойства и методы. Мы к ним имеем доступ как внутри класса, так и снаружи.
// Кроме публичных мы можем ещё объявлять приватные свойства и методы, которые будут доступны только внутри класса. 
// То есть к ним нельзя обратиться извне, в том числе и из дочерних классов.
// Указание свойству или методу того, что он является приватным осуществляется посредством специального символа #:
// class Person {
//   #name;
//   #age;
//   constructor(name, age) {
//     this.#name = name;
//     this.#age = age;
//   }
//   getName() {
//     return this.#name;
//   }
//   getAge() {
//     return this.#age;
//   }
//   setAge(value) {
//     if (Number.isInteger(value) && value > 0) {
//       this.#age = value;
//     }
//     throw new Error('Ошибка при установке значения свойству #age! Значение не является целым положительным числом.');
//   }
// }
// Для организации доступа к приватным свойствам (#name, #age) вместо обычных методов удобно использовать геттеры и сеттеры.
//      Геттеры и сеттеры
// Геттеры и сеттеры – это специальные методы, доступ к которым осуществляется через связанное с каждым из них свойство. 
// При этом геттер работает при чтении свойства, а сеттер – при присвоении свойству некоторого значения. 
// При написании геттера, его необходимо задавать соответственно без параметров, а сеттер – с одним параметром.
// Другими словами, геттер и сеттер позволяют создать на вид обычное свойство, но работающее через функции.
// Очень часто геттеры и сеттеры применяются соответственно для чтения приватных свойств и присвоения им новых значений:
// class Person {
//     #name;
//     #age;
//     constructor(name, age) {
//       this.#name = name;
//       this.#age = age;
//     }
//     // геттер для получения имени
//     get name() {
//       return this.#name;
//     }
//     // геттер для получения возраста
//     get age() {
//       return this.#age;
//     }
//     // сеттер для установки возраста
//     set age(value) {
//       if (Number.isInteger(value) && value > 0) {
//         return this.#age = value;
//       }
//       throw new Error('Ошибка при установке значения свойству #age! Значение не является целым положительным числом.');
//     }
// }
// В этом примере нельзя после создания объекта изменить свойство #name, а присвоение нового значения #age осуществляется 
// только после его успешной проверки. Для этого мы свойства #name и #age сделали приватными. После этого доступ к свойствам 
// #name и #age реализовали через геттеры. Геттеры отличаются от методов только наличием перед ними ключевого слова get.
// Так как #name изменять не нужно, то сеттер написали только для #age. Сеттер начинается с set, затем идёт имя и круглые скобки, 
// в которых обязательно указываем параметр с помощью которого мы будем получать значение для его установки свойству #age.
// Как вы уже поняли, свойство, связанное с сеттером или геттером определяется его именем. В этом примере – это name и age.