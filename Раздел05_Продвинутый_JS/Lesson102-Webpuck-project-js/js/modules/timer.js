function timer() {
    // Lesson 69. Timer + Lesson 70. Обработка прошедшей даты
    // в перем-ю поместим дату в виде строки, это будет наша отправ-я точка
    const deadline = '2022-12-08';

    // 1-я фун-я! опред-я разницу между deadline и нашим текущим временем, т.е разницу между датами
    function getTimeRemaining(endtime) {
        let days, hours, minutes, seconds;
        // нам нужно превр-ть строку в нечно осязаемое, испол-м Date.parce
        // получ-и кол-во мс в нашем конеч-м времени до кот-го нам нужно дойти
        // мы в пере-ю t получим разницу между этими датами в кол-ве мс
        const t = Date.parse(endtime) - Date.parse(new Date());
        // добавим обработка прошедшей даты(Lesson 70), опред-м будет ли значение у нас отриц-м, 
        // и если оно отриц-е то мы просто вернем нули 000 вместо наших значений
        if (t <= 0) {
            // устан-м знач-е 0 каждой перем-й
            days = 0;
            hours = 0;
            minutes = 0; 
            seconds = 0;
        } else {
        // тут нам нужно посч-ть кол-во дней отобр-я в нашем таймере
        // нам нужно взять кол-во мс и / на кол-во мс в одном дне и округлить все это
        //  days = Math.floor() - это округ-е до ближ-го целого\
        // где 1000 * 60 - кол-во мс в 1мин, еще на * 60 - кол-во в 1 часе, * 24 - кол-во в 1 дне
        // т.е тут (1000 * 60 * 60 * 24) мы получ-м сколько в сутках будем мс
        // и когда мы общее кол-во мс t / на (1000 * 60 * 60 * 24) мы получ-м сколько суток у нас осталось до оконч-я
        // нашей даты ('2020-05-11')
        days = Math.floor( (t/(1000*60*60*24)) );
        // t / на кол-во мс в 1 часе и так мы получим общее кол-во часов остав-ся до таймера
        // далее мы общее кол-во часов что получ-сь (t / 1000 * 60 * 60) делим через % на 24
        // т.е. мы напр. 50 / 24 и получ-м 2 дня, а остаток от деления, т.е. 2 часа, вер-ся и мы его помести к нам на сайт
        // в графу кол-ва часов остав-ся до конца акции
        hours = Math.floor( (t/(1000*60*60) % 24) );
        // и по похожему принципу мы будем считать и далее т.к. нам нужны именно "хвостики" а не общее кол-во!
        minutes = Math.floor( (t/1000/60) % 60 );
        // тут нам нужно просто разделить кол-во сек внутри мс
        seconds = Math.floor( (t/1000) % 60 );
        }
        

        // и что-бы мы могли испол-ть перем-е выше снаружи мы должны их вернуть, при этом мы будем возв-ть объект
        // такой прием часто испол-ся!!!
        return {
            // св-во total будет у нас - общее кол-во мс, куда соот. мы поместим значение t
            // в будущем нам нужна будем перем-я t, т.к. нам нужно знать не закон-ся ли таймер
            'total': t,
            'days': days,
            'hours': hours,
            'minutes': minutes,
            'seconds': seconds
            // в ссылке есть инфа как записать схожие по названию ключи и значения иначе
            // https://attacomsian.com/blog/javascript-object-property-shorthand
        };
    }

    // тут нам нужно подставить 0 в ячейки с днями и часами, чтобы было 09 дней и тд
    function getZero(num){
        // если пришед-е число от 0-10 тогда подст-м 0
        if (num >= 0 && num < 10) { 
            return '0' + num;
        } else {
            return num;
        }
    }

    // 2-я фун-я! когда у нас уже есть фун-я по расчету времен-х промежутков, напишем фун-ю устанав-ю наш таймер нам на стр-цу
    // для запуска этой фун-и нам понад-ся 2 аргум-та (selector, endtime)
    function setClock(selector, endtime) {
        // и что-бы настроить наш таймер нам нужен блок <div class="timer"> и deadline кот-й мы будем в него перед-ть
        // получ-м все нужные нам элем-ты со страницы
        const timer = document.querySelector(selector),
              days = timer.querySelector('#days'),
              hours = timer.querySelector('#hours'),
              minutes = timer.querySelector('#minutes'),
              seconds = timer.querySelector('#seconds'),
            // где фун-й будет высту-ть updateClock() и запус-я она будет через каждую сек
              timeInterval = setInterval(updateClock, 1000);

        // запус-м updateClock для инициализации(запустит текущ-ю дату) и отмены "моргания" таймера при обновлении страницы
        updateClock();

        // 3-я фун-я! обновляющая наш таймер каждую секунду, пишем ее внутри 2-й фун-и setClock
        // внутри себя она будет содер-ть 3 самых глав. действия
        function updateClock() {
            // 1. расчет времени что остался прямо на эту секунду и для этого испол. фун-ю getTimeRemaining
            // которрая возвр-т нужный нам объект с данными, где endtime это на дедлайн кот-й мы будем перед-ть в setClock
            const t = getTimeRemaining(endtime);
            // 2. теперь нам нужно поместить на стр-цу расчетные величины что мы получили
            // колич-во дней кот-е мы отобр-м на стр-це
            // и чтобы наш 0 при необ-ть подств-ся испол. фун-ю getZero
            days.innerHTML = getZero(t.days);
            hours.innerHTML = getZero(t.hours);
            minutes.innerHTML = getZero(t.minutes);
            seconds.innerHTML = getZero(t.seconds);
            // и когда эта фун-я запус-ся, она расч-т нужное нам время и на основ-и этих расчетов запишет на стр-цу 
            // необ. резул-ты, запуск фун-и будет в константе timeInterval
            // 3. И раз у нас уже есть интервал, то нам его нужно будет рано или поздно остановить
            // и для этого нам нужна будет перем-я t в 'total': t, т.к. в ней есть кол-во мс нужное нам
            // если наше ремя уже вышло, т.е. оно идет в отриц-ю сторону, то таймер мы уже не обновляем
            if (t.total <= 0) {
                // то мы просто будем остан-ть наш таймер
                clearInterval(timeInterval);
            }
        }
    }
    // устанав-м наши часы в фун-и setClock, где 1-й арг-т это наш селектор .timer, 
    // а 2-й наш дедлайн, в будущем данные в эту перем-ю могут прих-ть от сервера!
    setClock('.timer', deadline);
}
module.exports = timer;