// Lesson 83. AJAX и общение с сервером. Объект XMLHttpRequest

// Ajax
// Для сетевых запросов из JavaScript есть широко известный термин AJAX (англ. Asynchronous JavaScript and XML — 
// асинхронный JavaScript и XML) — это не технология сама по себе, а термин, который описывает «новый» подход к использованию 
// существующих технологий вместе. AJAX включает: HTML или XHTML, CSS, JavaScript, DOM, XML, XSLT, и объект XMLHttpRequest. 
// Когда эти технологии объединяются в модель AJAX, web-приложения способны делать быстрые дополняющие обновления интерфейса 
// пользователя без необходимости полной перезагрузки страницы браузером. Приложения работают быстрее и становятся более 
// отзывчивыми к действиям пользователей.

// Calculator
const inputUAN = document.querySelector('#hrivna'),
      inputUSD = document.querySelector('#usd'),
      inputEUR = document.querySelector('#eur'),
      fieldInfo = document.querySelector('#info');

// назначаем обработчик события input. Событие cрабатывает каждый раз при изменении значения.
inputUAN.addEventListener('change', () => {
    // Теперь нам нужно сделать запрос на сервер. Для отправки HTTP-запроса нужно создать XMLHttpRequest-объект
    // Конструктор XMLHttpRequest() создаёт новый объект XMLHttpRequest. У этого объекта есть свои методы, св-ва и события
    const request = new XMLHttpRequest();
    // 1-й метод который мы применим это open(). Этот метод позвол-т собрать необ-е в будущем наст-ки для запроса
    // Подр-е про этот метод, что принимает и тд внизу кода
    // request.open(method, url, async, login, password);
    request.open('get', 'js/current.json');   // остал-е пар-ры нам не нужны сейчас
    // далее нам нужно объяснить серверу что он принимает, для этого сущес-т http-заголовки
    // сейчас мы испол-м заголовок кот-й нужен для json файлов
    // мы указыв-м в () тип контента, далее какой именно тип + кодировка кот-ю испол-м
    request.setRequestHeader('Content-type', 'application/json; charset=utf-8');
    // и теперь мы уже можем отпр-ть запрос и делается это методом send(), кот-й по факту просто отправ-т инфо-ю
    // в () ничего не указ-м, т.к. метод отпр-ки 'get' не имеет своего тела запроса(body)
    request.send();
    // мы уже отправили запрос и далее с ним нужно что-то делать, когда прийдет ответ от сервера
    // У объекта XMLHttpRequest(request) также есть события кот-е относ-ся к нему
    // событие 'readystatechange' будет отслеж-ть готовность нашего запроса в данный текущий момент(испол-я редко)
    // событие 'load 'проще чем 'readystatechange' т.к. срабат-т только один раз когда запрос полностью готов
    // т.к. мы не можем знать когда точно ответит сервер
    request.addEventListener('load', () => {
        // что такое .readyState .status и .response в описании в конце кода!
        //  if (request.readyState === 4 && request.status === 200) 
        if (request.status === 200) {
            // мы уже получили результат и будем перев-ть(парсить) наш JSON объект в обычный понятный JS объект
            const data = JSON.parse(request.response);
            // далее нам нужно расчитать курс валют на основании того что нам пришло от сервера и что ввел польз-ль
            // берем value того что ввел польз-ль, где .current.usd это св-ва нашего объекта data(из JSON)
            // .toFixed(2) - это кол-во знаков после точки
            inputUSD.value = (+inputUAN.value / data.current.usd).toFixed(2);
            inputEUR.value = (+inputUAN.value / data.current.eur).toFixed(2);
            // иногда сервера у нас могут ломаться и нужно показать что что-то произошло
        } else {
            fieldInfo.style.cssText = 'display: block; color: red; font-size: 22px';
        }
    });

});


// Событие: change
// Событие change срабатывает по окончании изменения элемента. Для текстовых <input> это означает, что событие происходит 
// при потере фокуса. Пока мы печатаем в текстовом поле в примере ниже, событие не происходит. Но когда мы перемещаем фокус 
// в другое место, например, нажимая на кнопку, то произойдёт событие change

// Событие input 
// Cрабатывает каждый раз при изменении значения. В отличие от событий клавиатуры, оно работает при любых изменениях значений, 
// даже если они не связаны с клавиатурными действиями: вставка с помощью мыши или распознавание речи при диктовке текста.

// XMLHttpRequest 
// Это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки 
// страницы. Мы можем загружать/скачивать файлы, отслеживать прогресс и многое другое.
// На сегодняшний день не обязательно использовать XMLHttpRequest, так как существует другой, более современный метод fetch.
// XMLHttpRequest()
// Конструктор XMLHttpRequest() создаёт новый объект XMLHttpRequest. Для отправки HTTP-запроса нужно создать 
// XMLHttpRequest-объект, открыть URL и отправить запрос. После выпол-я запроса можно получить и обраб-ть тело и статус ответа.
// XMLHttpRequest имеет два режима работы: синхронный и асинхронный.
// Синтаксис: const myRequest = new XMLHttpRequest();
//          Его метод open()
// Этот метод обычно вызывается сразу после new XMLHttpRequest. В него передаются основные параметры запроса:
// - method – HTTP-метод. Обычно это "GET" или "POST". "GET" для получ-я данных от сервера, "POST" для отправ-я данных на сервер.
// - URL – URL, куда отправляется запрос: строка, может быть и объект URL. Тут путь нужно формир-ть относит-но HTML
// - async – если указать false, тогда запрос будет выполнен синхронно, это мы рассмотрим чуть позже. 
// Синхронный код идет по порядку, т.е. код долго выпол-ся то код ниже будет ее ждать.
// Асинхронный работает иначе, он не блокирует остальной код, в основном испол-ся именно он!
// И по умолчанию Ajax-запросы являются асинхронным кодом
// - login, - password – логин и пароль для базовой HTTP-авторизации (если требуется). Пример:
//  request.open(method, url, async, login, password);
// Заметим, что вызов open, вопреки своему названию, не открывает соединение. Он лишь конфигурирует запрос, но непосредственно 
// отсылается запрос только лишь после вызова send.
//          Его HTTP-заголовки
// XMLHttpRequest умеет как указывать свои заголовки в запросе, так и читать присланные в ответ.
// Для работы с HTTP-заголовками есть 3 метода:
// - setRequestHeader(name, value);
// Устанавливает заголовок запроса с именем name и значением value. Например:
// request.setRequestHeader('Content-Type', 'application/json');
// - getResponseHeader(name);
// Возвращает значение заголовка ответа name (кроме Set-Cookie и Set-Cookie2). Например:
// request.getResponseHeader('Content-Type');
// - getAllResponseHeaders();
// Возвращает все заголовки ответа, кроме Set-Cookie и Set-Cookie2.
//           Послать запрос.
// request.send([body])
// Этот метод устанавливает соединение и отсылает запрос к серверу. Необязательный параметр body содержит тело запроса.

// Когда мы уже отправили запрос, далее с ним нужно что-то делать, когда прийдет ответ от сервера
// для этого есть разл-е св-ва: 
// - status (404 и тд), есть отдел-й Список кодов состояния HTTP(в ссылках к уроку)
// - statusText: 404 Not Found («не найдено»)
// - response - это будет наш ответ от сервера, это тот ответ что задал backend-разработчик и мы будем испол-ть на клиенте
// - readyState - это текущее сост-е нашего запроса
// Свойство XMLHttpRequest.readyState возвр-т текущее сост-е объекта XMLHttpRequest. Объект request может иметь след-е состояния:
// Значение	Состояние	        Описание
//  0	    UNSENT	            Объект был создан. Метод open() ещё не вызывался.
//  1	    OPENED	            Метод open() был вызван.
//  2	    HEADERS_RECEIVED	Метод send() был вызван, доступны заголовки (headers) и статус.
//  3	    LOADING	Загрузка;   responseText содержит частичные данные.
//  4	    DONE	            Операция полностью завершена.
// И на основании этих св-в мы будем сторить дальнейшее взаимод-е

// У объекта XMLHttpRequest также есть события кот-е относ-ся к нему. События на request, чтобы получить ответ.
// Три наиболее используемых события:
// - load – происходит, когда получен какой-либо ответ, включая ответы с HTTP-ошибкой, например 404.
// Изменения в состоянии объекта запроса генерируют событие readystatechange:
// - error – когда запрос не может быть выполнен, например, нет соединения или невалидный URL.
// - progress – происходит периодически во время загрузки ответа, сообщает о прогрессе.

// Отмена запроса
// Если мы передумали делать запрос, можно отменить его вызовом request.abort():


// XMLHttpRequest, Fetch
// XMLHttpRequest (request) это JavaScript API для создания AJAX запросов. Методы этого объекта предоставляют возможность отправки 
// сетевых запросов между browser и server. XMLHttpRequest или - более новой - Fetch API. Эти технологии позволяют 
// веб-страницам напрямую обрабатывать запросы HTTP для определённых ресурсов, доступных на сервере, и форматировать 
// результирующие данные по мере необходимости перед их отображением.
// Fetch API предоставляет интерфейс для получения ресурсов (в том числе по сети). Он покажется знакомым любому, 
// кто использовал XMLHttpRequest, но новый API является более мощным и гибким набором функций.

// Есть несколько способов делать сетевые запросы и получать информацию с сервера.
// Метод fetch() — современный и очень мощный, поэтому начнём с него. Он не поддерживается старыми (можно использовать полифил), 
// но поддерживается всеми современными браузерами. Базовый синтаксис:
// let promise = fetch(url, [options])
// url – URL для отправки запроса.
// options – дополнительные параметры: метод, заголовки и так далее.
// Без options это простой GET-запрос, скачивающий содержимое по адресу url.