'use strict';
// Lesson 115. Событийный цикл: микрозадачи и макрозадачи

// Поток выполнения в браузере, равно как и в Node.js, основан на событийном цикле.
// Понимание работы событийного цикла важно для оптимизаций, иногда для правильной архитектуры.
// Идея событийного цикла очень проста. Есть бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их 
// и снова ожидает появления новых.
// Общий алгоритм движка:
// 1. Пока есть задачи: выполнить их, начиная с самой старой
// 2. Бездействовать до появления новой задачи, а затем перейти к пункту 1

// Это простая фун-я кот-я будет выводить в консоль сооб-е
setTimeout(() => console.log('timeout'));
// Далее обратимся к промису и сразу выполним его с функ-й resolve(), т.е. мы сразу говорим что-бы промис выпол-ся положительно
Promise.resolve()
// И раз уж он уже готов обратимся сразу к than и выпол-м команду
    .then(() => console.log('promise'));

    // Помещаем фун-ю которая выпол-ся, queueMicrotask, между 2-мя микро-задачами
    // И выпол-ся она также между 2-мя промисами, т.е. наше сооб-е стало в очередь микро-задач и выпол-сь по порядку
    queueMicrotask(() => console.log('wow'));

Promise.resolve()
    .then(() => console.log('promise_2'));
console.log('code');
// Порядок выпол-я примера выше будет след-м:
// code
// promise
// wow
// promise_2
// timeout

// Макро-задача - это задача выпол-я например промисом(Promise).

// Микро-задачи - это те что формир-ся внутри .then/catch/finally либо оператора await.
// Сущест-т очередь как макро-задач так и микро-задач и когда у нас завершается одна макро-задача
// выполняются все микро-задачи которые скопились в очереди, когда они все выпол-сь идет след-я макро-задача
// В микро-задачах также есть своя очередь и порядки, пример с queueMicrotask()

// Порядок выполнения схема:
// макро-задача: () => {}
// micro-task: then/catch/finally/await
// render (рендер или перерисовка на странице контента)
// след. макро-задача: () => {}
// micro-task: then/catch/finally/await
// render (рендер или перерисовка на странице контента) 
// след. макро-задача: () => {}  и тд





// Макрозадачи
// Это функции(setTimeout и тд), промисы и тд.

// Микрозадачи
// Обработчики промисов: .then/.catch/.finally/.await - всегда асинхронны.

// queueMicrotask():
// Принимает функцию, которая будет передана в очередь микрозадач; Возвращает undefined.
// Это специальная функция queueMicrotask(func), которая помещает func в очередь микрозадач.
// queueMicrotask() добавляет переданную функцию в очередь микрозадач. Функции в этой очереди выполняются одна за другой 
// — когда текущая функция выполнилась, запускается следующая функция в очереди. Все микрозадачи в очереди будут выполнены 
// только после того, как текущий стек вызовов окажется пустым, но перед выполнением следующей макрозадачей.
// Подр-е: https://doka.guide/js/queuemicrotask/
// Если мы хотим запустить функцию асинхронно (после текущего кода), но до отображения изменений и до новых событий, 
// то можем запланировать это через queueMicrotask. В этот раз использована функция queueMicrotask вместо setTimeout. 
// Обратите внимание – отрисовка страницы происходит только в самом конце. Как и в случае обычного синхронного кода.
// Подроб-е: https://learn.javascript.ru/event-loop#makrozadachi-i-mikrozadachi
// Если мы хотим запустить код в очереди микрозадач еще до рендеринга страницы то можно испол-ть queueMicrotask()

// API браузера (Browser APIs) — конструкции, встроенные в браузер, построенные на основе языка JavaScript, 
// предназначенные для облегчения разработки функциональности. API означает Application Programming Interface.
// Веб API - это интерфейс прикладного программирования для Интернета.

// Call stack
// Стек вызовов (call stack) - это механизм для интерпретаторов (таких как интерпретатор JavaScript в веб-браузере) для 
// отслеживания текущего местонахождения интерпретатора в скрипте, который вызывает несколько функций, — какая из функций 
// выполняется на данный момент, какие функции вызываются изнутри этой (выполняемой) функции, какая будет вызвана следующей и т.д.