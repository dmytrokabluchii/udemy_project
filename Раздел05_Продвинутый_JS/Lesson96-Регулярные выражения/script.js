'use strict';
// Lesson 96. Регулярные выражения (РВ)
// Регулярные выражения – мощный способ поиска и замены для строк.
// В JavaScript регулярные выражения реализованы отдельным объектом RegExp и интегрированы в методы строк.
// Регулярное выражение (оно же «регэксп», «регулярка» или просто «рег»), состоит из 2-х частей: 
// шаблона («паттерн») и необязательных флагов.

// Существует два синтаксиса для создания регулярного выражения.
//      «Длинный» синтаксис: regexp = new RegExp("шаблон", "флаги");
// new RegExp('pattern', 'flags');
//      И короткий синтаксис, использующий слеши "/":
// /шаблон/; /pattern/       // без флагов
// /шаблон/gmi;              // с флагами gmi (будут описаны далее)

// Шаблон проектирования наших регулярных выражений
// Самый 1-й метод с которым мы будем работать это метод .search(): т.е. он пытается что-то найти
// И когда найдет то возвр-т 1-й поряд-й номер найденого значения, т.е. он ищет только 1-е совпадение!
// В перем-й ans у нас будет нах-ся строка получ-я от пользователя(когда он ответит на вопрос)
// const ans = prompt('Enter your name');    // Dimon
const myName = 'Dimon';
// В перем-ю reg поместим наше РВ с паттерном. Допустим мы хочем найти в строке все буквы n
const reg = /n/;
// в строке получ-й от пол-ся(ans) есть метод .search(), где внутри () мы помещ-м то РВ по кот-му будем искать внутри строки
// console.log(ans.search(reg));     // 4
// Т.е. мы получили 4, это 4-й символ(нач. счет с 0) в слове Dimon. Если бы буквы n не было, мы бы получили -1

// Если нам нужно будет найти более одной буквы в строке, нам понад-ся флаги:
// i - это 1-й флаг, если мы хотим что-то найти вне завис-ти от регистра
const myName2 = 'DIMONNN';
const reg2 = /n/i;
console.log(myName2.search(reg2));   // 4 - т.е. нам вер-сь значение даже если оно с большой буквы в строке
// g - 2-й флаг(global), если мы хочем найти несколько "вхождений"
// const reg2 = /n/g;   // -1
// m - 3-й флаг, вкл-т многострочный режим, т.к. строки могут быть не в одну линию, а с переносами и тд
// И эти флаги можно комбинировать!
// const reg3 = /n/gmi;

// Т.к. метод .search() ищет только до 1-го совпадения, расмот-м еще метод .match
// Метод [@@match]() извлекает совпадения при сопоставлении строки с регулярным выражением.
console.log(myName2.match(reg2));   // ['N', index: 4, input: 'DIMON', groups: undefined]
// Т.е. этот метод возвр-т нам массив с данными[кусочек буквы что ищем, индекс на кот-й он найден, и сама строка 
// где был сделан поиск, и посл-м идет св-во groups:]. Этот метод мощнее и далее мы можем испол-т св-ва их этого массива!
// Далее найдем все n в строке испол-я этот метод
const reg3 = /n/ig;
console.log(myName2.match(reg3));   // (3) ['N', 'N', 'N']

// метод замены части строки .replace, где в () 1-м арг-м идет то что заменяем, а 2-м то на что меняем
// в 1-й арг-т поместим регул-е выраж-е и мы можем делать это прямо в аргументе
// const pass = prompt('Password');
// const pass = 'Dimon19';
// В регул-х выр-х точка между /./ - означает что мы берем все элементы(прим. флаг глоб-ти g) кот-е попадают в строку
// (как * в css) и далее просто земеняем их на *. В резул-те наш пароль зашифруется и такой прием часто испол-ся!
// console.log(pass.replace(/./g, "*"));  // *****
//      Если нам нужно чтобы "экранировать" введенный символ, например точки, мы перед ней ставим \
// console.log(pass.replace(/\./g, "*"));   // dima***   а мы ввели dima...
// И в РВ есть много спец. символов - например чтобы найти в строке такой слеш \ мы его должны экранир-ть таким же \
// Тоже самое относится к многим символам, например: ^ & | - без экранир-я они имеют свои нюансы(подр-е в документации читать)
// Например в примере ниже мы захочем убрать все - и поменять из на :
console.log('12-34-56'.replace(/-/g, ':'));   // 12:34:56

// У РВ как у объекта есть свои методы, например .test(). Он проверяет, есть ли хоть одно совпадение, если да, 
// то возвращает true, нет совпадений - false.
const myName4 = 'Nika';
const reg4 = /n/ig;
console.log(reg4.test(myName4));   // true  т.к. в имени есть N


// Символьные классы. Также в РВ есть классы
// Символьный класс – это специальное обозначение, которое соответствует любому символу из определённого набора.
// \d («d» от английского «digit» означает «цифра») - класс «цифра», значит что мы ищем цифры. Цифра: символ от 0 до 9.
// В примере ниже мы хочем находить только числа. В итоге мы увидим введенные цифры
// const writeNumber = prompt('Enter number');    // мы ввели dima1984lev
const regNum = /\d/;
// console.log(writeNumber.match(regNum));  // ['1', index: 4, input: 'dima1984lev', groups: undefined]
// или
const regNum2 = /\d/g;
// console.log(writeNumber.match(regNum2));   // (4) ['1', '9', '8', '4']
// это удобно когда нам нужно убрать все буквы например и оставить только цифры
const writeSomething = '200px';
const regNum3 = /\d/g;
console.log(writeSomething.match(regNum3));   // (3) ['2', '0', '0'] и далее с этими знач-ми можно работать

// \s («s»: от английского «space» – «пробел») -  класс «пробел», значит что мы ищем пробелы.
// Пробельные символы: включает в себя символ пробела, табуляции \t, перевода строки \n и некоторые другие редкие 
// пробельные символы, обозначаемые как \v, \f и \r. 
// Пробелы мы можем искать след-м способом: / /ig;

// \w («w»: от английского «word» – «слово») - класс «буква», значит что мы ищем буквы.
// Символ «слова», а точнее – буква латинского алфавита или цифра или подчёркивание _. Нелатинские буквы не являются частью 
// класса \w, то есть буква русского алфавита не подходит.

// Все примеры выше можно испол-ть аналог-м способом. Такие классы можно комбин-ть прим-я более сложные констр-и
// В задаче ниже нам нужно вырезать R2D2 и сделать это по какому-то шаблону, где /\w\d\w\d/i это и будет наш шаблон
// по кот-му мы будем искать что-то внутри нашей строки
const str = 'My name is R2D2';
console.log(str.match(/\w\d\w\d/i));  // ['R2D2', index: 11, input: 'My name is R2D2', groups: undefined]
// где \w - означает что мы хотим найти констр-ю начин с буквы, \d - далее идет цифра, \w - буква, \d - цифра


// Обратные символьные классы
// Для каждого символьного класса существует «обратный класс», обозначаемый той же буквой, но в верхнем регистре.
// «Обратный» означает, что он соответствует всем другим символам, синтаксис такой же как и выше только буква большая, например:
// \D - Не цифра: любой символ, кроме \d, например буква.
// \S - Не пробел: любой символ, кроме \s, например буква.
// \W - Не буквы, то есть не буквы из лат-цы, не знак подчёрк-я и не цифра. В част-ти, русские буквы прин-т этому классу
// Например мы ищем все не буквы
const str2 = 'My name is R2D2';
console.log(str2.match(/\W/i));   // [' ', index: 2, input: 'My name is R2D2', groups: undefined] где 1-я не буква то пробел
console.log(str2.match(/\W/g));   // (3) [' ', ' ', ' ']
console.log(str2.match(/\D/g));   // ) ['M', 'y', ' ', 'n', 'a', 'm', 'e', ' ', 'i', 's', ' ', 'R', 'D'] где цифр уже нет
console.log(str2.match(/\S/g));   //  ['M', 'y', 'n', 'a', 'm', 'e', 'i', 's', 'R', '2', 'D', '2']



// Примеры с урока WebDev с нуля https://www.youtube.com/watch?v=_pLpx6btq6U
// Массив создали испол-я регул-е выражения
// ["Канада","США","Китай","Бразилия","Австралия"]

// Регулярное выражение-шаблон для номера карточки
// Например для номера карты: 4444 4545 8545 8545
const strNumCard = '4444 4545 8545 8545';
const regNumCard = /\d{4} \d{4} \d{4} \d{3}/g;
console.log(strNumCard.match(regNumCard));   // [ '4444 4545 8545 8545' ]

// Поработаем с номером телефона в формате: Var 1
const strNumCard2 = '+38(050)6671923';
const regNumCard2 = /^\+38\(\d{3}\)\d{7}/g;
console.log(strNumCard2.match(regNumCard2));    // [ '+38(050)6671923' ]
// Var 2
const strNumCard3 = '+38(050)667-19-23';
const regNumCard3 = /^\+38\(\d{3}\)\d{3}\-\d{2}\-\d{2}/g;
console.log(strNumCard3.match(regNumCard3));    // [ '+38(050)667-19-23' ]

// Поработаем с email







// pattern — это повторяемая архитектурная конструкция, шаблон, представляющая собой решение проблемы проектирования 
// в рамках некоторого часто возникающего контекста. Паттерны проектирования представляют собой обобщение опыта профессиональных 
// разработчиков ПО. Паттерн проектирования можно рассматривать как некий шаблон, в соответствии с которым пишут программы.

// Флаг - это специальная переменная, которое может принимать только два значения: true и false. С помощью флагов можно решать 
// задачи, проверяющие отсутствие чего-либо: к примеру, можно проверить, что в массиве нет элемента с определенным значением

// Синтаксис: Возможны как литеральная запись, так и запись через конструктор:
// new RegExp(pattern, flags)
// /pattern/flags
// Параметры:
// pattern - Текст регулярного выражения.
// flags - Если определён, может принимать любую комбинацию нижеследующих значений:
// g - глобальное сопоставление
// i - игнорирование регистра при сопоставлении
// m - сопоставление по нескольким строкам; символы начала и конца (^ и $) начинают работать по нескольким строкам (то есть, 
//     происходит сопоставление с началом или концом каждой строки (строки разделяются символами \n или \r), а не только с 
//     началом или концом всей вводимой строки)
// y - «липкий» поиск; сопоставление в целевой строке начинается с индекса, на который указывает свойство lastIndex этого 
//     регулярного выражения (и не пытается сопоставиться с любого более позднего индекса).

// Поиск: Метод search() 
// выполняет поиск совпадения между регулярным выражением и строкой.

// Поиск: str.match 
// Метод match() извлекает совпадения при сопоставлении строки с регулярным выражением.

// Замена: str.replace 
// Метод .replace(regexp, replacement) заменяет совпадения с regexp в строке str на replacement 
// (все, если есть флаг g, иначе только первое).
// В строке замены replacement мы можем использовать специальные комбинации символов для вставки фрагментов совпадения:
// Спецсимволы	Действие в строке замены
// $&	вставляет всё найденное совпадение
// $`	вставляет часть строки до совпадения
// $'	вставляет часть строки после совпадения
// $n	если n это 1-2 значное число, вставляет содержимое n-й скобочной группы регулярного выражения, 
// $<name>	вставляет содержимое скобочной группы с именем name, также изучим в главе Скобочные группы
// $$	вставляет символ "$"
// console.log("Люблю HTML".replace(/HTML/, "$& и JavaScript") );    // Люблю HTML и JavaScript

// Проверка: regexp.test
// Метод regexp.test(str) проверяет, есть ли хоть одно совпадение, если да, то возвращает true, иначе false.

// Квантификаторы +, *, ? и {n}
//      Количество {n}
// Самый простой квантификатор — это число в фигурных скобках: {n}. Можно по-разному указать количество, например:
// Точное количество: {5}
// Шаблон \d{5} обозначает ровно 5 цифр, он эквивалентен \d\d\d\d\d. Следующий пример находит пятизначное число:
// console.log( "Мне 12345 лет".match(/\d{5}/) ); //  "12345"
// Мы можем добавить \b, чтобы исключить числа длиннее: \b\d{5}\b.
// Диапазон: {3,5}, от 3 до 5
// Для того, чтобы найти числа от 3 до 5 цифр, мы можем указать границы в фигурных скобках: \d{3,5}

//      +
// Означает «один или более». То же самое, что и {1,}. Например, \d+ находит числа (из одной или более цифр):
// let str = "+7(903)-123-45-67";
// console.log( str.match(/\d+/g) ); // 7,903,123,45,67

//      ?
// Означает «ноль или один». То же самое, что и {0,1}. По сути, делает символ необязательным.
// Например, шаблон ou?r найдёт o после которого, возможно, следует u, а затем r.
// Поэтому шаблон colou?r найдёт два варианта: color и colour:
// let str = "Следует писать color или colour?";
// console.log( str.match(/colou?r/g) ); // color, colour

//      *
// Означает «ноль или более». То же самое, что и {0,}. То есть символ может повторяться много раз или вообще отсутствовать.
// Например, шаблон \d0* находит цифру и все нули за ней (их может быть много или ни одного):
// console.log( "100 10 1".match(/\d0*/g) ); // 100, 10, 1
