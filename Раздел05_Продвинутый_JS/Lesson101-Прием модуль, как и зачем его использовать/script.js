'use strict';
// Lesson 101 Прием модуль, как и зачем его использовать

// По мере роста нашего приложения, мы обычно хотим разделить его на много файлов, так называемых «модулей». 
// Модуль обычно содержит класс или библиотеку с функциями.
// Модули по своей струк-ре самодостаточны и независимы и хорошо разраб-й модуль никак не зависит от другого кода
// и может быть легко изменен или удален, если нужно. Также модули обеспечивают чистоту глобал-го пространства, 
// позволяют избежать "загрязнения" глоб-го пространства и избежать конфликтных ситуаций с одинак-ми именами,
// ведь все данные модуля сущест-т только в его собств-й области видимости.

// Существует 2 способа реализации модулей через нативную реализацию:
//      1. Используем анонимную самовызыв-ся фун-ю
const number = 1;
// Сиснтаксис ниже это прием анонимной(т.к. нет имени) самовызыв-ся(т.к. она сразу вызыв-ся на месте () в конце кода) фун-и
// Этот прием позвол-т написать код, сразу его запустить и получить локальную область видимости
// Если мы не обернем всю фун-ю в () то получим function declaration(она не может быть анонимной) и ошибку
// А внешние () позволяют перевести фун-ю в function expression и она может быть без имени
// При помощи такой фун-и мы можем создать собственную обл-ть видимости
(function () {
    // здесь находится приватная область видимости
    let number = 2;
    console.log(number);       // 2
    console.log(number + 3);   // 5
}());
console.log(number);   // 1

// 2. Испол-е объектного интерфейса. Модуль мы записываем в перем-ю и в нее возвр-м методы доступные снаружи
const user = (function() {
    // К фун-и ниже мы не будем иметь доступа т.к. она нах-ся в локал. области видимости
    const privat = function() {
        console.log('I am privat!');      // I am privat!
    };
    // но мы можем из аноним-й фун-и выше вернуть объект, этот приём наз-ся объектный интерфейс
    return {
        // далее в метод sayHello мы перед-м ссылку на нашу приватную фун-ю privat
        sayHello: privat
    };
}());
// далее вызовем метод sayHello() в перм-й user
user.sayHello();
// Итого: наша анонимная самовыз-ся фун-я созд-т объект, она экспортирует(return) только те методы(или св-ва) 
// которые нам нужны будут снаружи, мы этот объект запис-м в перем-ю(user) и через . мы можем обращ-ся к этим 
// методам(или свойствам) user.sayHello(). И с классами это будет работать так же!
// В будущем мы такие конструкции прописывать не будем, т.к. это будет делать спец. инструмент WebPuck








// Управлять областью видимости переменных в JavaScript можно, пользуясь паттерном «Модуль». Для того чтобы создать 
// приватную область видимости, можно воспользоваться замыканием. Как известно, функции создают собственные области видимости, 
// содержимое которых отделено от глобальной области видимости:
(function () {
    // здесь находится приватная область видимости
})();
