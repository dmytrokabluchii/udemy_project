'use strict';
// Lesson 88. Методы перебора массивов (.filter(), map(), every(), some(), reduce(), entries())

// Методы map(), .filter(), reduce(), entries() - возвращают новый массив!

// forEach
// Этот метод просто перебирает массив и не возвр-т новый!

// filter()
// Этот метод будет фильтровать элементы внутри масива
const namesFamily = ['Dima', 'Nastya', 'Veronika', 'Natalya'];
// Задача получить имена которые меньше 5 символов
// При этом во внутрь этого метода мы перед-м callback фун-ю, кот-я переб-т эл-ты и возвр-т только те что подх-т под наше условие
// где (name) это каждый отдел-й элемент внутри массива
const shortNames = namesFamily.filter( (name) => {
    // из этой фун-и мы возвр-м только то имя длина которого менее 5 символов
    return name.length < 5;
});
console.log(shortNames);    // [ 'Dima' ]
// Еще вариант
const number = [12, 3, 56, 137, 999];
const rezNum = number.filter( (num) => {
    return num > 100;
});
console.log(rezNum);   // [ 137, 999 ]


// map()
// Позволяет взять исходный массив и изменить каждый элемент внутри него, на выходе у нас будет новый массив с измен-ми данными
const answers = ['DiMa', 'NasTyA', 'Nika'];
// Приведем к нижнему регистру все имена в массиве, т.е. исправим косяки при введении данных пользователем
const resaltMap = answers.map( (item) => {
    return item.toLowerCase();
});
// или можно сократить до: const resaltMap = answers.map(item => item.toLowerCase());
console.log(resaltMap);   // [ 'dima', 'nastya', 'nika' ]

// также можно переделать на вариант когда меняется и сам исходный массив(но лучше исходные данные оставлять без измен-й)
let answers2 = ['DiMa', 'NasTyA', 'Nika'];
answers2 = answers2.map(item => item.toLowerCase());
console.log(answers2);   // [ 'dima', 'nastya', 'nika' ]


// some() / every()
// - some() проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции. Возвр-т boolean
// - every() проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции. Возвр-т boolean
const someString = [5, 'Dima', 'www'];
// Проверим есть ли внутри нашего массива хотябы одно число
console.log(someString.some(item => typeof(item) === 'number'));   // true
console.log(someString.every(item => typeof(item) === 'number'));  // false


// reduce()
// нужен что-бы схлопывать или соедин-ть массив в одно единое целое
const arrReduce = [4, 5, 2, 11];
// нужно вывести сумму всех чисел в массиве. И тут нам понад-ся уже колбэк фун-я приним-я 2 аргумента
const rezReduce = arrReduce.reduce( (sum, current) => sum + current);
console.log(rezReduce);   // 22
// Вариант со строками
const arrReduce2 = ['Dima', 'Nastya'];
const rezReduce2 = arrReduce2.reduce( (sum, current) => `${sum} ${current}`);
console.log(rezReduce2);    // Dima Nastya
// Метод reduce() может принимать еще один аргумент
const arrReduce3 = [4, 5, 2, 11];
const rezReduce3 = arrReduce3.reduce( (sum, current) => sum + current, 3);
console.log(rezReduce3);   // 25   т.е. 22 + 3


// entries()
// Этот метод уже относ-я к объектам, он позволяем превр-ть объект в "матрицу"(массив массивов)
// Таким образом мы можем из объекта сделать массив и далее работать с ним как уже с массивом!
const obj = {
    dima: 'person',
    nastia: 'person',
    dog: 'animal',
    cat: 'animal'
};
const newArr = Object.entries(obj);
console.log(newArr);  // [ [ 'dima', 'person' ], [ 'nastia', 'person' ], [ 'dog', 'animal' ], [ 'cat', 'animal' ] ]

// Задача вытащить имена(в ключе) с объекта, когда данные условно прих-т с сервера и мы не знаем на каких поз-х они нах-ся
const obj2 = {
    dima: 'person',
    nastia: 'person',
    dog: 'animal',
    cat: 'animal'
};
const newArr2 = Object.entries(obj2)
// ниже идет продол-е кода выше, где мы получим массив с 'person', таким образом мы можем запус-ть методы по цепочке
.filter(item => item[1] === 'person')
// console.log(newArr2);   // [ [ 'dima', 'person' ], [ 'nastia', 'person' ] ]
// далее получим только 1-й элемент в массиве и в резул-те мы выполним задачу
.map(item => item[0]);
console.log(newArr2);      // [ 'dima', 'nastia' ]


//                                            Шпаргалка по методам массива:

// ! Для добавления/удаления элементов:
// - push (...items) – добавляет элементы в конец,
// - pop() – извлекает элемент с конца,
// - shift() – извлекает элемент с начала,
// - unshift(...items) – добавляет элементы в начало.
// - splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
// - slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
// - concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из 
// items является массивом, тогда берутся его элементы.

// ! Для поиска среди элементов:
// - indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
// - includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
// - find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию 
// возвращается true.
// - findIndex похож на find, но возвращает индекс вместо значения.

// ! Для перебора элементов:
// - forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.

// ! Для преобразования массива:
// - map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
// - sort(func) – сортирует массив «на месте», а потом возвращает его.
// - reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
// - split/join – преобразует строку в массив и обратно.
// - reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая 
// промежуточный результат между вызовами.

// Дополнительно:
// - Array.isArray(arr) проверяет, является ли arr массивом.
// - every() проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.
// - some() проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции.
// Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.
// Изученных нами методов достаточно в 99% случаев, но существуют и другие.