{"version":3,"file":"bundle.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCxCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAO,CAAC,gCAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./src/js/main.js","webpack:///webpack/bootstrap","webpack:///./src/js/script.js"],"sourcesContent":["// Webpack. Сборщик модулей. Собираем наш проект\r\n\r\n// Модули CommonJS\r\nfunction myModule() {\r\n    this.hello = function() {\r\n        console.log('hello');\r\n    };\r\n    this.goodbye = function() {\r\n        console.log('bye');\r\n    };\r\n}\r\n// Нам ну чтобы фун-я выше перешла из теущего файла(main.js) в index.js где мы ее сможем испол-ть много раз\r\n// Далее испол-м синксис CommonJS. Ниже обратимся к объекту module, у кот-го есть св-во exports\r\n// И в него мы помещаем то что хочем экспортировать\r\nmodule.exports = myModule;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//  CommonJS — это добровольная рабочая группа, которая проектирует, прототипирует и стандартизирует различные JavaScript API. \r\n// На сегодняшний день они ратифицировали стандарты для модулей и пакетов — CommonJS определяют простой API для написания \r\n// модулей, которые могут быть использованы в браузере с помощью тега <script>, как с синхронной, так и с асинхронной загрузкой.\r\n// В структурном плане, CommonJS-модуль представляет собой готовый к переиспользованию фрагмент JavaScript-кода, который \r\n// экспортирует специальные объекты, доступные для использования в любом зависимом коде. CommonJS все чаще используется как \r\n// стандартный формат JavaScript-модулей. Существует большое количество уроков по написанию CommonJS-модулей, но обычно они \r\n// описывают две главных идеи: \r\n// - объект exports, содержащий то, что модуль хочет сделать доступным для других частей системы, и \r\n// - функцию require, которая используется одними модулями для импорта объекта exports из других.\r\n\r\n// Установка Webpack. Данные с оф. сайта по установке\r\n// Все эти команды не нужно выполнять. Опишу каждую поподробнее:\r\n// mkdir webpack-demo - создает новую папку внутри текущей с названием webpack-demo (нам это не нужно)\r\n// cd webpack-demo - мы в терминале заходим в эту папку (тоже не нужно)\r\n// npm init -y - инициализация проекта (не нужно)\r\n// npm install webpack webpack-cli --save-dev - команда по установке webpack, нам пригодится!\r\n// webpack.config.js - это наш конфигурац-й файл\r\n// Далее выполним: npx webpack\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// Webpack. Сборщик модулей. Собираем наш проект\r\n\r\n// Импортируем фун-ю с main.js\r\n// испол-м синтаксис фун-и require, которая импоритирует код, где в () укажем путь к файлу, без .js\r\n// Т.к. далее сборщик Webpack сам поймет что за файл ему нужно испол-ть!\r\nconst myNewModule = require('./main');\r\n\r\n// Далее мы создадим объект с нашей функ-й\r\nconst myModuleInstance = new myNewModule();\r\n// и теперь мы сможем испол-ть методы фун-и из main.js\r\nmyModuleInstance.hello();\r\nmyModuleInstance.goodbye();\r\n\r\n// Браузер не может собирать модули самостоятельно, и в текущем виде просто выдаст ошибку что он не знает фун-и require\r\n// Любая модульная система должна быть собрана в один результирующий файл, и для сборки модулей нам и поможет сборщик Webpack!\r\n// Он может не только собирать скрипты в кучу, но и конфигурировать наш проект, обраб-ть стили, картинки, формир-ть папки и тд\r\n// При этом GULP - это планировщик задач, при помощи него мы можем собирать разные \"таски\"(tasks - задачи), кот-е выпол-ся\r\n// в различных обстоят-х, сам по себе он не может собирать скрипты, обраб-ть изобр-я и тд, он лиш подкл-т к себе определ-е\r\n// модули и запускает определ-е задачи когды мы это требуем.\r\n// Webpack - это как раз сборщик модулей, мы его настраиваем и запускаем что бы он собирал проект и эти технологии, \r\n// GULP и Webpack могут комбинир-ся вместе, т.е. при помощи GULP мы можем запускать Webpack!\r\n"],"names":[],"sourceRoot":""}