{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI;;;;;;;;;;;;;;;AC/I8B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU,MAAM,SAAS;AACpD,kDAAkD,WAAW;AAC7D;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAW;AACf;AACA;AACA;AACA;AACA,4BAA4B,IAAI;AAChC,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,8CAA8C,IAAI,yDAAyD,EAAE,WAAW,EAAE;AAC1H;AACA;AACA;AACA,4BAA4B,IAAI;AAChC;AACA;AACA;AACA,gCAAgC,iCAAiC;AACjE;AACA;AACA;AACA,SAAS;AACT,KAAK,GAAG;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAK,MAAM,OAAO;AAC7C,kDAAkD,MAAM;AACxD,gDAAgD,MAAM;AACtD;AACA;AACA;AACA,0DAA0D,MAAM;AAChE;AACA;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA;AACA,iEAAe,KAAK;;;;;;;;;;;;;;;;AC1H0B;AACA;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4DAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,wCAAwC,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAU;AACtB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,IAAI;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,EAAE,GAAG,EAAE,GAAG,EAAE;AAC9E;AACA;AACA,iEAAe,KAAK;;;;;;;;;;;;;;;;ACrHpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;AACD;AACD;;;;;;;;;;;;;;;AC1FnB;AACA,iBAAiB,qFAAqF;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,cAAc;AAC3D,+CAA+C,WAAW;AAC1D,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA,iEAAe,MAAM;;;;;;;;;;;;;;AC3LrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA,iEAAe,IAAI;;;;;;;;;;;;;;AChEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK;;;;;;;;;;;;;;;AC3GpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,IAAI,YAAY,WAAW;AACtE;AACA;AACA;AACA;AACA;AACkB;;;;;;;UCvClB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;ACNA;AACkC;AACE;AACA;AACA;AACE;AACJ;AACE;AACM;AAC1C;AACA;AACA;AACA;AACA,0CAA0C,yDAAS;AACnD;AACA,IAAI,yDAAI;AACR;AACA,IAAI,0DAAK;AACT;AACA,IAAI,0DAAK;AACT,IAAI,0DAAK;AACT;AACA,IAAI,2DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,yDAAI;AACR,IAAI,0DAAK;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,oGAAoG;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,gCAAgC;AAChC,+CAA+C;AAC/C,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://food-local-practice/./js/modules/calc.js","webpack://food-local-practice/./js/modules/cards.js","webpack://food-local-practice/./js/modules/forms.js","webpack://food-local-practice/./js/modules/modal.js","webpack://food-local-practice/./js/modules/slider.js","webpack://food-local-practice/./js/modules/tabs.js","webpack://food-local-practice/./js/modules/timer.js","webpack://food-local-practice/./js/services/services.js","webpack://food-local-practice/webpack/bootstrap","webpack://food-local-practice/webpack/runtime/define property getters","webpack://food-local-practice/webpack/runtime/hasOwnProperty shorthand","webpack://food-local-practice/webpack/runtime/make namespace object","webpack://food-local-practice/./js/script.js"],"sourcesContent":["function calc() {\r\n    // Lesson 97-98. Создаем калькулятор на сайте\r\n    const calcResult = document.querySelector('.calculating__result span');\r\n    let sex, height, weight, age, ratio;\r\n    // Установим в localStorage введенные польз-м значения и значения по дефолту\r\n    if (localStorage.getItem('sex')) {\r\n        // то заносим эти знач0я в перем-ю sex\r\n        sex = localStorage.getItem('sex');\r\n    } else {\r\n        // если такого значения нет, мы вручную задаем то знач-е кот-е нас интересует\r\n        sex = 'female';\r\n        localStorage.setItem('sex', 'female');\r\n    }\r\n    if (localStorage.getItem('ratio')) {\r\n        // то заносим эти знач-я в перем-ю sex\r\n        ratio = localStorage.getItem('ratio');\r\n    } else {\r\n        // если такого значения нет, мы вручную задаем то знач-е кот-е нас интересует\r\n        ratio = 1.375;\r\n        localStorage.setItem('ratio', 1.375);\r\n    }\r\n\r\n    // Фун-я при заходе на стр-цу будет очищать класс активности у кнопок и во время перебора элементов\r\n    // будет проверять когда кнопка совпадет по значению, с ratio например, запис-му с localStorage\r\n    // то на эту кнопку будем навешивать класс активности\r\n    function initLocalSettings(selector, activeClass) {\r\n        const elements = document.querySelectorAll(selector);\r\n        elements.forEach(elem => {\r\n            // Сначала удалим у элементов класс активности\r\n            elem.classList.remove(activeClass);\r\n            // Переберем элементы с id и если id будет = значению что наход. в localStorage 'sex'\r\n            if (elem.getAttribute('id') === localStorage.getItem('sex')) {\r\n                // и если условие выше хоть раз выпол-ся то данному элементу мы назначим класс-активности\r\n                elem.classList.add(activeClass);\r\n            }\r\n            // Далее проверим элементы с атрибутами\r\n            if (elem.getAttribute('data-ratio') === localStorage.getItem('ratio')) {\r\n                // И если знач-я выше совпадают то элементу(блоку) мы назн-м класс активности\r\n                elem.classList.add(activeClass);\r\n            }\r\n        });\r\n    }\r\n    // Запускаем фун-и с 2 арг-ми, тоже самое делали с фун-й getStaticInformation\r\n    initLocalSettings('#gender div', 'calculating__choose-item_active');\r\n    initLocalSettings('.calculating__choose_big div', 'calculating__choose-item_active');\r\n \r\n    // Фун-я общего вычисления калорий, должна вызыв-я каждый раз когда на стр-це проис-т измен-е\r\n    function calcTotal() {\r\n        // если у нас нет(не введено), т.е. если хот-бы одно их этих условий выпол-ся(будет false)\r\n        if (!sex || !height || !weight || !age || !ratio) {\r\n            // то тогда мы не будем рассчит-ть\r\n            calcResult.textContent = '____';\r\n            // далее досрочно прервем фун-ю\r\n            return; \r\n        }\r\n        // если же все данные будут заполнены, то\r\n        if (sex === 'female') {\r\n            // Формула расчета базовой нормы калорий:\r\n            // для женщин: BMR = 447.6 + (9.2 x вес, кг) + (3.1 х рост, cм) – (4.3 х возраст, лет)\r\n            // Метод Math.round() возвращает число, округлённое к ближайшему целому.\r\n            calcResult.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio);\r\n        } else {\r\n            // для мужчин: BMR = 88.36 + (13.4 x вес, кг) + (4.8 х рост, см) – (5.7 х возраст, лет)\r\n            calcResult.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio);\r\n        }\r\n    }\r\n    calcTotal();\r\n\r\n    // Фун-я получ-я статических данных по калориям и перекл-ю активности, в уроке 98 немного доработали ее\r\n    function getStaticInformation(selector, activeClass) {\r\n        // получаем все div элементы внутри родителя\r\n        const elements = document.querySelectorAll(selector);\r\n        // Исправ-м баги при клике на поля вне кнопок\r\n        elements.forEach(elem => {\r\n            // далее отслеж-м клики по родит-му элементу(parentSelector) кот-й содер-т все div и\r\n            // испол-ть при этом будем делегир-е событий\r\n            elem.addEventListener('click', (e) => {\r\n                // если при клике на элемент он содержит атрибут ...\r\n                if(e.target.getAttribute('data-ratio')) {\r\n                    // то мы получ-м значение этого атрибута как число\r\n                    ratio = +e.target.getAttribute('data-ratio');\r\n                    // занесем в localStorage записанные полз-м данные\r\n                    localStorage.setItem('ratio', +e.target.getAttribute('data-ratio'));\r\n                } else {\r\n                    // если у элемента не будет атрибута, то получ-м знач-е id элемента\r\n                    sex = e.target.getAttribute('id');\r\n                    localStorage.setItem('sex', e.target.getAttribute('id'));\r\n                }\r\n                // Т.к. выше мы уже получили все знач-я элементов, нам нужно поработать с классами активности\r\n                // сначала удалим все классы активности у элем-в, а потом назначим только тому кот-й нужен\r\n                elements.forEach(elem => {\r\n                    elem.classList.remove(activeClass);\r\n                });\r\n                // и тому элементу на кот-й кликнули назнач-м класс активности\r\n                e.target.classList.add(activeClass);\r\n                // В конце каждой из фун-й вызываем calcTotal(), что-бы примен-сь измен-я на стр-це\r\n                calcTotal();\r\n            });\r\n        });\r\n    }\r\n    // теперь нам нужно запустить фун-ю выше с 2 статич. элементами, где 1-м арг-м идет блок с id=\"gender\"\r\n    // а 2-м наш класс активности\r\n    getStaticInformation('#gender div', 'calculating__choose-item_active');\r\n    // При 2-м вызове укажем нашего родителя, класс активности при этом не меняется\r\n    getStaticInformation('.calculating__choose_big div', 'calculating__choose-item_active');\r\n\r\n    // Далее созд-м фун-ю кот-я будет обраб-ть каждый отдел-й input\r\n    function getDinamicInformation(selector) {\r\n        const input = document.querySelector(selector);\r\n        // Событие input срабатывает каждый раз при изменении значения.\r\n        input.addEventListener('input', () => {\r\n            // Если мы видим в input что-то кроме чисел, исправить это можем испол-я РВ\r\n            if (input.value.match(/\\D/g)) {\r\n                // то бордер делаем красным, иниче убераем его\r\n                input.style.border = '1px solid red';\r\n            } else {\r\n                input.style.border = 'none';\r\n            }\r\n\r\n            // когда польз-ль что-то вводит. Конструкция switch заменяет собой сразу несколько if.\r\n            switch(input.getAttribute('id')) {\r\n                // если наш input с id = height\r\n                case 'height':\r\n                    // то запис-м в нее знач-е кот-е ввел польз-ль и прерыв-м операцию(break)\r\n                    height = +input.value;\r\n                    break;\r\n                case 'weight':\r\n                    weight = +input.value;\r\n                    break;\r\n                case 'age':\r\n                    age = +input.value;\r\n                    break;\r\n            }\r\n        // В конце каждой из фун-й вызываем calcTotal(), что-бы примен-сь измен-я на стр-це\r\n        calcTotal();\r\n        });\r\n    }\r\n    // Далее нам нужно выз-ть фун-ю выше с 3-мя разными селекторами\r\n    getDinamicInformation('#height');\r\n    getDinamicInformation('#weight');\r\n    getDinamicInformation('#age');\r\n\r\n}\r\nexport default calc;","import {getResource} from '../services/services';\r\n\r\nfunction cards() {\r\n    // Lesson 79. Используем классы в реальной работе\r\n    // Задача: шаблонизировать карточки с меню и созд-ть их перед-я только нужные аргум-ты\r\n    // Для этой задачи будем испол-ть классы и создан-е динамич-х элементов на стр-це с перед-й аргум-в\r\n    // В ...classes испол-м оператор rest из Lesson 80. Т.к. мы не знаем сколько еще может добав-ся аргум-в\r\n    class MenuCard {\r\n        constructor(src, alt, title, description, price, parentSelector, ...classes) {\r\n            this.src = src;\r\n            this.alt = alt;\r\n            this.title = title;\r\n            this.description = description;\r\n            this.price = price;\r\n            this.classes = classes;\r\n            // в this.parent помещаем DOM элемент(нащего родителя в верстке) кот-й в дальн-м мы сможем испол-ть\r\n            this.parent = document.querySelector(parentSelector);\r\n            // сюда запишем статич-й курс валют(в будущем можно поменять если курс будет прих-ть от сервера)\r\n            this.transfer = 27;\r\n            // вызовем метод ниже changeToUAN() что-бы он уже верн-л нам прав-е значение\r\n            this.changeToUAN();\r\n        }\r\n        // добавим метод кот-й будет заниматься конвер-й валюты\r\n        changeToUAN() {\r\n            this.price *= this.transfer;\r\n        }\r\n        // здесь мы сфор-м нашу верстку(елементы куда помещ-ся отпер-я верстка), потом допол-ть\r\n        // верстку данными кот-е прих-т от аргум-в и поместить элемент на стр-цу\r\n        render() {\r\n        // сформир-м сам div элемент куда мы поместим нашу верстку\r\n        const element = document.createElement('div');\r\n        // если мы ничего не перед-м в ...classes\r\n            if (this.classes.length === 0) {\r\n                // тогда мы будем ставить дефолт-й класс\r\n                this.element = 'menu__item';\r\n                element.classList.add(this.element);\r\n            } else {\r\n                // т.е. если не было передано ни одного класса сформ-м их самост-но\r\n                // т.к. в classes у нас будет наход-ся массив елементов(его вернет оператор ...rest), переб-м его\r\n                this.classes.forEach(className => element.classList.add(className));\r\n            }     \r\n            // innerHTML позво-т нам динам-ки сформир-ть HTML стр-ру наших карточек\r\n            element.innerHTML = `\r\n                <img src=${this.src} alt=${this.alt}>\r\n                <h3 class=\"menu__item-subtitle\">${this.title}</h3>\r\n                <div class=\"menu__item-descr\">\r\n                ${this.description}\r\n                </div>\r\n                <div class=\"menu__item-divider\"></div>\r\n                <div class=\"menu__item-price\">\r\n                    <div class=\"menu__item-cost\">Цена:</div>\r\n                    <div class=\"menu__item-total\"><span>${this.price}</span> грн/день</div>\r\n                </div>\r\n            `;\r\n            // помещ=м наш элемент во внутрь родителя\r\n            this.parent.append(element);\r\n        }\r\n    }\r\n\r\n    // Пересоберем наши карточки new MenuCard()  Lesson 90\r\n    getResource('http://localhost:3000/menu')\r\n    // далее обрабат-м наш ответ с сервера, он(data) к нам приходит уже в транфор-м виде объекта(т.е. массива)\r\n    .then(data => {\r\n        // переб-м все элементы получ-го массива(а он в свою очередь сост. их объектов)\r\n        // Ниже испол-м синтаксис деструктур-и объекта - это когда мы из объекта(db.json) вытаск-м отдел-е св-ва в качестве \r\n        // отдел-й перем-й {img}. И теперь нам не нужно пост-но обращ-ся к obj\r\n        data.forEach(({img, altimg, title, descr, price}) => {\r\n            // т.е. это конст-р будет созд-ся столько раз сколько у нас будет объектов внутри массива, кот-й приходит от сервера\r\n            // В '' помещаем родителя, т.е. куда мы будем все это пушить\r\n            new MenuCard(img, altimg, title, descr, price, '.menu .container').render();\r\n        });\r\n    });\r\n\r\n    // Lesson 91. Библиотека axios. Отправим запрос этим методом, в () помещаем наш URL-адресс\r\n    /* axios.get('http://localhost:3000/menu')\r\n        // .then(data => console.log(data));  // {data: Array(3), status: 200, statusText: 'OK', headers: {…}, config: {…}, …}\r\n        // Т.е. выше она вернет нам все данные о нашем запросе в виде уже готового обычного объекта\r\n        // переб-м все элементы получ-го массива(а он в свою очередь сост. их объектов)\r\n        // Ниже испол-м синтаксис деструктур-и объекта - это когда мы из объекта(db.json) вытаск-м отдел-е св-ва в качестве \r\n        // отдел-й перем-й {img}. И теперь нам не нужно пост-но обращ-ся к obj\r\n        .then(data => { \r\n            // небол-е измен-е, нам нужно обрат-ся к данным кот-е мы получили от axios (data.data), а не к объекту с общей инфо\r\n            // это поведение описано в докумен-и к axios\r\n            data.data.forEach(({img, altimg, title, descr, price}) => {\r\n            // т.е. это конст-р будет созд-ся столько раз сколько у нас будет объектов внутри массива, кот-й приходит от сервера\r\n            // В '' помещаем родителя, т.е. куда мы будем все это пушить\r\n            new MenuCard(img, altimg, title, descr, price, '.menu .container').render();\r\n        });\r\n    }); */\r\n        \r\n\r\n    // Есть еще 2-й альтернативный вариант создания динамических элементов на стр-це(getResource перем-сь в services.js)\r\n    // Он часто испол-ся, но не формир-т классы, а испол-т верстку на лету:\r\n    /* getResource('http://localhost:3000/menu')\r\n    // далее вызовем сформир-ю ниже фун-ю и в () добавим данные кот-е она будет отраб-ть(data, т.е. то что прих-т с сервера)\r\n    .then(data => createCard(data));\r\n    // далее когда мы получ-м данные нам нужно запустить фун-ю, кот-я будет созд-ть карт-ки на стр-це\r\n    // При этом допустим что у нас нет никакго шаблона(шаблонизации) и карточки нам нужно сфор-ть только один раз\r\n    // При этом мы созд-м фун-ю, но это будет фун-я уже, а не класс\r\n    function createCard(data) {\r\n        data.forEach(({img, altimg, title, descr, price}) => {\r\n            // т.к. у нас нет никакой шаблонизации все элементы созд-м тут внутри\r\n            const element = document.createElement('div');\r\n            // назнач-м класс елементу выше\r\n            element.classList.add('menu__item');\r\n            // далее во внутрь элемента просто помещаем верстку\r\n            element.innerHTML = `\r\n                <img src=${img} alt=${altimg}>\r\n                <h3 class=\"menu__item-subtitle\">${title}</h3>\r\n                <div class=\"menu__item-descr\">${descr}</div>\r\n                <div class=\"menu__item-divider\"></div>\r\n                <div class=\"menu__item-price\">\r\n                    <div class=\"menu__item-cost\">Цена:</div>\r\n                    <div class=\"menu__item-total\"><span>${price}</span> грн/день</div>\r\n                </div>\r\n            `;\r\n            // Далее нам нужно поместить куда-то тот элемент что только-что создали\r\n            document.querySelector('.menu .container').append(element);\r\n        });\r\n    } */\r\n\r\n}\r\nexport default cards;","import {closeModal, openModal} from './modal';\r\nimport {postDada} from '../services/services';\r\n\r\nfunction forms(formSelector, modalTimerId) {\r\n    // Forms  Lesson 84 Реализация скрипта отправки данных на сервер\r\n    const forms = document.querySelectorAll(formSelector);\r\n    // Создадим объект со списком фраз которые мы будем испол-ть в коде далее. \r\n    const message = {\r\n        loading: 'icons/spinner.svg',\r\n        success: 'Спасибо, Скоро мы с вами свяжемся',\r\n        failure: 'Ошибка, что-то пошло не так'\r\n    };\r\n    // берем все наши формы и под каждую из них подвяз-м фун-ю postData. Объект FormData имеет метод forEach\r\n    forms.forEach(item => {\r\n        // эта фун-я и будет обработ-м события при отправке\r\n        bindPostData(item);\r\n    });\r\n\r\n    // Функ-я отвеч-я за привязку к постингу данных с сервера(в Lesson 90 переим-м ее)\r\n    function bindPostData(form) {\r\n        // навеш-м событие 'submit' и оно будет сраб-ть каждый раз когда форма отправ-ся\r\n        form.addEventListener('submit', (e) => {\r\n            // отмен-м станд-е поведение браузера(у нас это перез-ка при отправке данных)\r\n            e.preventDefault();\r\n            // Созд-м и показываем блок с соот. сообщение о ...\r\n            let statusMessage = document.createElement('img');\r\n            // подгруж-м нашу svg картинку. Атрибут src подгр-м из message.loading\r\n            statusMessage.src = message.loading;\r\n            // примен-м css стили к картинке\r\n            statusMessage.style.cssText = `\r\n                display: block;\r\n                margin: 0 auto;\r\n            `;\r\n            // form.append(statusMessage);  // изменили в lesson 85\r\n            form.insertAdjacentElement('afterend', statusMessage);\r\n\r\n            // для отправки данных с формы есть два способа, 1-й: Объект FormData 2-й: JSON формат\r\n            // какой выбрать зависит во многом от сервера(какой формат передачи данных он поддер-т)\r\n            const formData = new FormData(form);\r\n\r\n            // 2-й: JSON формат(в lesson 90 модиц-м код ниже)\r\n            // Метод Object.entries(obj) – возвращает массив пар [ключ, значение]. И далее из получ-ся стр-ры сделаем обыч. объект\r\n            // Испол-м для этого метод Object.fromEntries. А JSON.stringify превр-т все уже в json-объект\r\n            const json = JSON.stringify(Object.fromEntries(formData.entries()));\r\n\r\n            // Ниже перед .then испол-м нашу фун-ю postDada, во внутрь() кот-й поместим URL-адресс и body который пойдет на сервер\r\n            // где в body мы из обыч. объекта делаем JSON-объект и далее отправ-м его на сервер\r\n            postDada('http://localhost:3000/requests', json)\r\n            // теперь нам нужно обработать результат нашего запроса, при помощи промисов\r\n            // где data это как раз те данные что возвр-ся у нас из промиса, т.е. те что нам вернул сервер\r\n            .then(data => {\r\n                // После отправки данных с формы мы увидим их не только в консоли но и в нашем db.json в объекте \"requests\"\r\n                // И в будущем эти данные мы сможем испол-ть, если они нам будут нужны.\r\n                console.log(data);      // {name: 'Вероника', phone: '+38 (067) 902-42-38', id: 1}\r\n                // меняем сооб-е с объекта на .success\r\n                showThanksModal(message.success);\r\n                // чтобы надпись исчезла через время\r\n                    statusMessage.remove();\r\n            // И что-бы обработ-ть возможные ошибки пропишем метод catch()\r\n            }).catch( () => {\r\n                // если запрос не прошел то\r\n                showThanksModal(message.failure);\r\n            // И в самом конце пропишем метод finally() для очистки нашей формы после отправки\r\n            }).finally( () => {\r\n                // очищаем нашу форму после отправки, метод reset() делает это\r\n                form.reset();\r\n            });\r\n        });\r\n    }\r\n\r\n    // Lesson 85. Красивое оповещение пользователя, Spinner\r\n    function showThanksModal(message) {\r\n        // Получаем блок modal__dialog\r\n        const prevModalDialog = document.querySelector('.modal__dialog');\r\n        // скрываем временно блок при помощи стилей\r\n        prevModalDialog.classList.add('hide');\r\n        // запустим фун-ю openModal() отвеч-ю за откр-е модал-х окон\r\n        openModal('.modal', modalTimerId);\r\n        // Созд-м блок-обертку для нашего окна и задаем ему необ. классы\r\n        const thanksModal = document.createElement('div');\r\n        // Т.е мы один modal__dialog заменяем другим\r\n        thanksModal.classList.add('modal__dialog');\r\n        // Далее просто формир-м верстку кот-я будет наход-ся в данном модал. окне\r\n        thanksModal.innerHTML = `\r\n            <div class=\"modal__content\">\r\n                <div class=\"modal__close\" data-close>×</div>\r\n                <div class=\"modal__title\">${message}</div>\r\n            </div>\r\n        `;\r\n        // получ-м модал окно и помещаем его на стр-цу\r\n        document.querySelector('.modal').append(thanksModal);\r\n        // и чтобы наше старое модал окно отображалось, удалим thanksModal через 5 сек и соот. покажем prevModalDialog\r\n        setTimeout( () => {\r\n            thanksModal.remove();\r\n            prevModalDialog.classList.add('show');\r\n            prevModalDialog.classList.remove('hide');\r\n            closeModal('.modal');\r\n        }, 5000);\r\n    }\r\n\r\n    // Lesson 89 - работа с JSON-Server\r\n    // Подключаем наш JSON файл(db.json далее заменим его на http://localhost:3000/menu) испол-я метод fetch, \r\n    // fetch('http://localhost:3000/menu') \r\n    // // fetch возвр-т промис и мы его обраб-м метом .then()\r\n    // // где data - это наш ответ от сервера, а далее просто превратим его в js-объект - (data.json())\r\n    // .then(data => data.json())\r\n    // // далее берем тот резул-т кот-й получится (res) и просто выведем его в консоль\r\n    // .then(res => console.log(res));   // {menu: Array(3), requests: Array(0)}\r\n    // в консоли мы видим объект с массивами данных внутри, кот-е нам нужны будут в будущем при постороении карточек меню(menu)\r\n    // в объект requests при этом мы будем уже постить данные и для этого нам нужны будут POST-запросы и соот. устан. JSON-Server\r\n    // после запуска сервера командой: npx json-server db.json  мы увидем такие энпойнты, пути куда можно делать запросы:\r\n    // http://localhost:3000/menu http://localhost:3000/requests\r\n    // для дальнейшей работы с этим сервером мы скопируем адресс http://localhost:3000/menu и подставим его уже вместо \r\n    // назван-я файла ('db.json') в fetch\r\n    // И в резул-те в консоли мы увидим уже не объект а массив: [{…}, {…}, {…}] т.к. мы обратились уже к /menu, а это уже массив\r\n    // В будущем нужно будет запускать и локальный сервер и JSON-Server для работы с этим и др. проектами!\r\n}\r\nexport default forms;","// фун-я открыв-я модал. окно\r\nfunction openModal(modalSelector, modalTimerId) {\r\n    const modalWindow = document.querySelector(modalSelector);\r\n\r\n    // показыв-м и скрываем наше мод. окно, т.е. актив-м соот. css классы + есть вариант с toggle\r\n    modalWindow.classList.add('show', 'fade-modal');\r\n    modalWindow.classList.remove('hide');\r\n    // альтерн-й вариант с toggle\r\n    // modalWindow.classList.toggle('show');\r\n    // когда мы откр-м модал. окно у нас добав-ся стиль не позвол-й прокручивать стр-цу\r\n    document.body.style.overflow = 'hidden';\r\n    // если у нас есть modalTimerId то запустим очистку таймера\r\n    if (modalTimerId) {\r\n        clearInterval(modalTimerId);\r\n    }\r\n}\r\n\r\n// Фун-я закрывающая мод. окно\r\nfunction closeModal(modalSelector) {\r\n    const modalWindow = document.querySelector(modalSelector);\r\n    // скрываем и показыв-м наше мод. окно\r\n    modalWindow.classList.add('hide');\r\n    modalWindow.classList.remove('show');\r\n    // альтерн-й вариант с toggle\r\n    // modalWindow.classList.toggle('show');\r\n    // восстанав-м скролл на стр-це после закрытия, если остав-м '' то браузер сам решит что ставить по дефолту\r\n    document.body.style.overflow = '';\r\n}\r\n\r\nfunction modal(triggerSelector, modalSelector, modalTimerId) {\r\n    // Modal Lesson 72. Создаем модальное окно\r\n    const btnModalOpen = document.querySelectorAll(triggerSelector),\r\n          modalWindow = document.querySelector(modalSelector);\r\n        //   btnModalClose = document.querySelector('[data-close]');\r\n\r\n    // переберем наши кнопки btnModalOpen чтобы мы могли с любой кнопки откр-ть модал.окно\r\n    btnModalOpen.forEach(btn => {\r\n        // ! Испол-м спец. синтаксис запуска фун-и openModal, стрел-я фун-я оборач-т вызыв-ю фун-ю и она выпол-ся уже после клика\r\n        btn.addEventListener('click', () => openModal(modalSelector, modalTimerId));\r\n    });\r\n \r\n    // только после сраб-я клика у нас выпол-ся фун-я closeModal\r\n    // btnModalClose.addEventListener('click', closeModal);\r\n    // реал.функ-л закрытия модал. окна по клику вне мод. окна\r\n    // вешаем обраб-к клика на модал-е окно, где в () в callback фун-и помещ-м обьект события(e или event)\r\n    modalWindow.addEventListener('click', (e) => {\r\n        // e.target - куда кликнул польз-ль или \"крестик\"\r\n        // т.е. если этот атрибут 'data-close' будет при клике мы закроем модал. окно\r\n        if(e.target === modalWindow || e.target.getAttribute('data-close') == '') {\r\n            closeModal(modalSelector);\r\n        }\r\n    });\r\n    // реал-м функ-л закрытия модал. окна по нажатию на кнопку клав-ры ESC\r\n    // Событие keydown срабатывает, когда клавиша была нажата.\r\n    document.addEventListener('keydown', (e) => {\r\n        // у нашего объекта событие (e) есть св-во .code, кот-е может отслеж-ть код нашей клавиши\r\n        // code – физической код клавиши на клавиатуре; для клав-ши ESC это будет 'Escape'\r\n        // есть спец.сайты где можно узнать как имен-ся необ. клавиша по нажатию на нее https://www.toptal.com/developers/keycode\r\n        // и чтобы фун-я пост-я не запус-ст когда мы нажимаем ESC в условие добавим доп. проверку\r\n        // Метод Node.contains() возвращает Boolean значение, указывающее, является ли узел потомком данного узла, \r\n        // т.е. проверяет, находится ли элемент ('show') в теле страницы.\r\n        if (e.code === 'Escape' && modalWindow.classList.contains('show')) {\r\n            closeModal(modalSelector);\r\n        }\r\n    });\r\n    \r\n    // Lesson 73 продол-е. \r\n    // чтобы при пролистывании до конца мод. окно постоянно не вылазило созд-м фун-ю \r\n    function showModalByScroll() {\r\n        // 2.Когда пользов-ль долистал стр-цу до конца появляется модал-е окно\r\n        // Свойство Element.scrollHeight (только чтение) - измерение высоты контента в элементе, \r\n        // включая содержимое, невидимое из-за прокрутки.\r\n        // pageYOffset - свойство окна Window , доступное только для чтения. Это то же свойство, что и scrollY и, \r\n        // как таковое, оно тоже возвращает количество пикселей, на которое прокручен документ по вертикали (вниз или вверх).\r\n        // window.pageYOffset - это прокруч-я часть\r\n        // Document.documentElement - свойство только для чтения, которое возвращает элемент Element(тема парам-ры докум-а)\r\n        // document.documentElement.clientHeight - это видимая часть которую мы прямо сейчас видим на сайте(без прокрутки)\r\n        // document.documentElement.scrollHeight - значит что польз-ль долистал до конца стр-цы\r\n        // -1 (px) указыв-м чтобы не было возможных багов в некот-х браузерах\r\n        if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight -1) {\r\n            openModal(modalSelector, modalTimerId);\r\n            // чтобы при пролистывании до конца окно постоянно не вылазило\r\n            window.removeEventListener('scroll', showModalByScroll);\r\n        }\r\n    }\r\n    // чтобы удал-ть обраб-к события нужно делать и ссылку на фун-ю кот-я испол-сь и это showModalByScroll\r\n    window.addEventListener('scroll', showModalByScroll);\r\n}\r\nexport default modal;\r\nexport {closeModal};\r\nexport {openModal};\r\n","// Испол-м деструктуризацию {}\r\nfunction slider({container, slide, nextArrow, prevArrow, totalCounter, currentCounter, wrapper, field}) {\r\n    // Slider 92. Создаем слайдер на сайте\r\n    const slider = document.querySelector(container),\r\n          slides = slider.querySelectorAll(slide),\r\n          arrowPrev = slider.querySelector(prevArrow),\r\n          arrowNext = slider.querySelector(nextArrow),\r\n          totalSliderCounter = slider.querySelector(totalCounter),\r\n          currentSliderCounter = slider.querySelector(currentCounter),\r\n          slidesWrapper = slider.querySelector(wrapper),\r\n          slidesField = slider.querySelector(field),\r\n        // Метод Window.getComputedStyle() возвр-т объект, содер-й знач-я всех CSS-свойств элемента\r\n        // Где в () наход-ся наша общая обертка для слайдов\r\n        // window.getComputedStyle(slidesWrapper) вернет нам объект с CSS-свойствами и мы возм-м с него ширину\r\n          width = window.getComputedStyle(slidesWrapper).width;\r\n\r\n    // Индекс опред-й полож-е в текущем слайде, где 1 это номер нашего слайда\r\n    let slideIndex = 1;\r\n    // Для работы с отступами, чтобы мы знали насколько отступили влево-вправо\r\n    let offset = 0;\r\n\r\n    // Отображаем или нет 0 в общем счетчике слайдов\r\n    if (slides.length < 10) {\r\n        // .textContent - Позволяет задавать или получать текстовое содержимое элемента и его потомков.\r\n        totalSliderCounter.textContent = `0${slides.length}`;\r\n        currentSliderCounter.textContent = `0${slideIndex}`;\r\n    } else {\r\n        totalSliderCounter.textContent = slides.length;\r\n        currentSliderCounter.textContent = slideIndex;\r\n    }\r\n\r\n    // Устан-м ширину блоку в 100%\r\n    // Т.е. мы помещ-м все слайды что есть на стр-це(slides.length) во внуть slidesField и чтобы они все помес-сь полностью\r\n    slidesField.style.width = 100 * slides.length + '%';\r\n    // Установ-м блоку slidesField css св-во display: flex;\r\n    slidesField.style.display = 'flex';\r\n    // Добавим плавности блоку при перек-и слайдов и далее скроем неиспол-е слайды\r\n    slidesField.style.transition = '0.5s all';\r\n    slidesWrapper.style.overflow = 'hidden';\r\n\r\n    // Переб-м все слайды на стр-це, где внутри нах-ся каждый отдел-й слайд (slide)\r\n    slides.forEach(slide => {\r\n        // И каждому слайду устнан-м опред-ю ширину что нас интересует. В рез-те мы будем уверены что все слайды будут\r\n        // одинаковой ширины и все они помес-ся в перем-ю slidesField\r\n        slide.style.width = width;\r\n    });\r\n\r\n    // Lesson 94 Сделаем индикаторы(буллеты) для нашего слайдера\r\n    // Теперь все элементы внутри слайдера что абсол-но спозиц-ны будут норм. отображ-ся\r\n    slider.style.position = 'relative';\r\n    // Создадим блок 'ol' для наших индикаторов и добавим ему класс\r\n    const indicators = document.createElement('ol'),\r\n          dots = [];\r\n    indicators.classList.add('carousel-indicators');\r\n    // Вставим Css стили для наших индикаторов испол-я .cssText\r\n    indicators.style.cssText = `\r\n        position: absolute;\r\n        right: 0;\r\n        bottom: 0;\r\n        left: 0;\r\n        z-index: 15;\r\n        display: flex;\r\n        justify-content: center;\r\n        margin-right: 15%;\r\n        margin-left: 15%;\r\n        list-style: none;\r\n    `;\r\n    // Далее размещ-м этот блок на стр-це, т.е append наши indicator в блок slider\r\n    slider.append(indicators);\r\n    // Созд-м необ-е нам кол-во буллетов. Цикл закон-ся тогда когда конч-ся слайды(slides.length)\r\n    for (let i = 0; i < slides.length; i++) {\r\n        // Созд-м точки и добавим им атрибут c нумерацией нач-я с 1(i + 1), т.к. 1-й слайд - 1-я точка\r\n        const dot = document.createElement('li');\r\n        dot.setAttribute('data-slide-to', i + 1);\r\n        // И для красивого отображения добавим им Css стили\r\n        dot.style.cssText = `\r\n            box-sizing: content-box;\r\n            flex: 0 1 auto;\r\n            width: 30px;\r\n            height: 6px;\r\n            margin-right: 3px;\r\n            margin-left: 3px;\r\n            cursor: pointer;\r\n            background-color: #fff;\r\n            background-clip: padding-box;\r\n            border-top: 10px solid transparent;\r\n            border-bottom: 10px solid transparent;\r\n            opacity: .5;\r\n            transition: opacity .6s ease;\r\n        `;\r\n        // Добавим подсветки активности буллетам при соот. слайде\r\n        if(i == 0) {\r\n            dot.style.opacity = 1;\r\n        }\r\n        // Далее аппендим их в наш \r\n        indicators.append(dot);\r\n        // Далее мы получим массив с нашими буллетами\r\n        dots.push(dot);\r\n    }\r\n\r\n    // Фун-я превр-я строку в числов. тип данных и вырезающая все не числа, испол-ся регул-е выражения\r\n    // /\\D/g - где \\D это не числа, а g глобал-ть, т.е. мы заменим все не числа на пустую строку'', т.е. удалим их\r\n    function doNumberFromString(str) {\r\n        return +str.replace(/\\D/g, '');\r\n    }\r\n\r\n    // Назначим обраб-к события для передвижения нашего слайдера, на кнопку Next\r\n    arrowNext.addEventListener('click', () => {\r\n        // И когда слайдер долистает до конца, мы должны вернуть его в начал-е положение\r\n        // Если отступ(offset) будет равен ширине 1 слайда * на кол-во слайдов -1, то мы устан-м offset в 0\r\n        // В width у нас будет наход-ся нечто '500px' и нам нужно будет прев-ть его в число и вырезать px\r\n        if (offset == doNumberFromString(width) * (slides.length -1)) {\r\n            offset = 0;\r\n            // Если это будет не последний слайд, нам нужно будет добавить смещение\r\n        } else {\r\n            // offset +=  +width.slice(0, width.length - 2);\r\n            offset +=  doNumberFromString(width);\r\n            // Т.е. когда мы кликаем на стрелку Next к offset добав-я ширина еще одного слайда и слайд смест-ся на опредю велич-у\r\n        }\r\n        transformSlidesLeft();\r\n        // При перем-и слайдов мы также должны контр-ть slideIndex в Счетчике. Если мы дошли до конца слайда(slides.length)\r\n        if (slideIndex == slides.length) {\r\n            slideIndex = 1;\r\n        } else {\r\n            slideIndex++;\r\n        }\r\n        showZeroInCounterSlider();\r\n        setStyleDots();\r\n\r\n    });\r\n\r\n    // Далее сделаем немного схожие действия для кнопки arrowPrev\r\n    arrowPrev.addEventListener('click', () => {\r\n        // изменим условие, когда у нас будет ровно 1-й слайд (offset == 0), мы перем-я в самый конец\r\n        if (offset == 0) {\r\n            // т.е. в пере-ю offset мы запишем наш посл-й слайд вычисл-й по след-й формуле\r\n            offset = doNumberFromString(width) * (slides.length -1);\r\n            // И если это был не 1-й слайд то знач-е нужно отнимать\r\n        } else {\r\n            offset -=  doNumberFromString(width);\r\n        }\r\n        transformSlidesLeft();\r\n        // При перем-и слайдов мы также должны контр-ть slideIndex в Счетчике.\r\n        // Если мы на 1-м слайде, то при клике на кнопку пред-го слайда мы будем смещ-ся в самый конец\r\n        if (slideIndex == 1) {\r\n            slideIndex = slides.length;\r\n            // кол-во слайдов соот. умен-ся при нажатии\r\n        } else {\r\n            slideIndex--;\r\n        }\r\n        showZeroInCounterSlider();\r\n        setStyleDots();\r\n    });\r\n\r\n    // Далее нам нужно на наши буллеты добавить перек-е слайдов при клике\r\n    dots.forEach(dot => {\r\n        dot.addEventListener('click', (e) => {\r\n            const slideTo = e.target.getAttribute('data-slide-to');\r\n            // при клике на соот. буллет у нас в slideIndex пойдет соот номер буллета(1 или 5 и тд)\r\n            slideIndex = slideTo;\r\n            // в пере-ю offset мы запишем наш посл-й слайд вычисл-й по след-й формуле\r\n            // где doNumberFromString(width) - общая ширина при расчете\r\n            offset = doNumberFromString(width) * (slideTo -1);\r\n            transformSlidesLeft();\r\n            showZeroInCounterSlider();\r\n            setStyleDots();\r\n        });\r\n    });\r\n    \r\n    // Фун-я перебора массива буллетов dots, где каждой точке dot устанав-м инлайн-стили\r\n    function setStyleDots() {\r\n        dots.forEach(dot => dot.style.opacity = '.5');\r\n        dots[slideIndex - 1].style.opacity = 1;\r\n    } \r\n    // Фун-я отображения 0 в счетчике слайдов\r\n    function showZeroInCounterSlider() {\r\n        if (slides.length < 10) {\r\n            currentSliderCounter.textContent = `0${slideIndex}`;\r\n        } else {\r\n            currentSliderCounter.textContent = slideIndex;\r\n        }\r\n    }\r\n    // Фун-я делаем смещение сашего слайдера, для смешения влево в css мы указ-м отриц. знач-я\r\n    function transformSlidesLeft() {\r\n        slidesField.style.transform = `translateX(-${offset}px)`;\r\n    }\r\n}\r\nexport default slider;","function tabs(tabsSelector, tabsContentSelector, tabsParentSelector, activeClass) {\r\n    // Lesson 64. Tabs\r\n    const tabs = document.querySelectorAll(tabsSelector),\r\n          tabsContent = document.querySelectorAll(tabsContentSelector),\r\n    // родитель кот-й будет содер-ть все наши табы(тема делегирование событий)\r\n          tabsParent = document.querySelector(tabsParentSelector);\r\n\r\n    // делаем фун-ю(она может быть универсальной) где скрываем все ненуж-е нам табы!\r\n    function hideTabContent() {\r\n        // т.к. это псевдомассив нам его нужно перебрать, где item - это каждый отдел-й контент\r\n        tabsContent.forEach(item => {\r\n                // т.е. добав-м к item css стиль - display = 'none', кот-й скрывает контент\r\n                // item.style.display = 'none';\r\n            // чтобы добавить анимацию при перек-и табов нам нужны будут css классы при перек-и, а не inline стили испол-е выше\r\n            // класс 'hide' прячет контент (display = 'none')\r\n            // класс 'show' показ-т контент (display = 'block')\r\n            // класс 'fade' у нас отвеч-т за анимацию\r\n            item.classList.add('hide');\r\n            item.classList.remove('show', 'fade');\r\n        });\r\n        // убер-м класс активности у всех табов которые нам не нужны будут\r\n        tabs.forEach(item => {\r\n            item.classList.remove(activeClass);\r\n        });\r\n    }\r\n\r\n    // теперь делаем фун-ю которая будет показывать нам таб-контент(она может быть универсальной)!\r\n    // где i - это элемент(номер) к кот-му мы обращ-ся и кот-й нужно будет показать.\r\n    // в ES6 есть такой функционал где мы можем устан-ть значение по умолчанию уже в нашей фун-и! \r\n    // Т.е. если мы выз-м фун-ю без аргум-та, то у нас вместо i будет подст-ся 0. Т.е. i мы сразу присв-м 0 !\r\n    function showtabContent(i = 0) {\r\n            // испол-м inline стили при перекл-и, но также в перек-и часто испол-т и классы(далее рассмотрим)\r\n            // tabsContent[i].style.display = 'block';\r\n        // для того что бы у нас работали классы и соот. анимация заменим пример выше на:\r\n        tabsContent[i].classList.add('show', 'fade');\r\n        tabsContent[i].classList.remove('hide');\r\n        tabs[i].classList.add(activeClass);\r\n    }\r\n    // чтобы фун-и выше заработали не забываем их вызывать после!\r\n    hideTabContent();\r\n    // арг-м в() устан-м в фун-и по умолчанию, т.е. 0, в ES6 функ-и мы можем сразу присв-ть 0, (i = 0)\r\n    showtabContent();\r\n\r\n    // испол-я делегирование, созд-м событие на клик\r\n    tabsParent.addEventListener('click', (event) => {\r\n        // если мы часто будем испол-ть событие event.target мы можем опред-ть его в перем-ю\r\n        const target = event.target;\r\n        // tabsSelector.slice(1) - удалим точку у нашей строки(метод сформ-т новую строку без 1-го символа)\r\n        if (target && target.classList.contains(tabsSelector.slice(1))) {\r\n            // методом перебора делаем расп-е куда кликнул польз-ль и подст-м соот. по номеру элемент для показа\r\n            // где item - это каждый таб что бы будем передавать, а i - это номер элемента по порядку(согласно синтаксису метода)\r\n            tabs.forEach((item, i) => {\r\n                // если target(тот элемент в кот-й мы кликнули) будет совпадать с элементом что мы перебираем\r\n                if(target == item) {\r\n                    // вызыв-м 2 фун-и т.к. при перекл-и мы должны скрыть остальные и ост-ть только нужную\r\n                    hideTabContent();\r\n                    // где в i хранит-ся нужный нам номер по порядку\r\n                    showtabContent(i);\r\n                }\r\n            });\r\n        }\r\n    });\r\n}\r\n// Далее просто экспортируем эту функ-ю в модули\r\nexport default tabs;","function timer(id, deadline) {\r\n    // Lesson 69. Timer + Lesson 70. Обработка прошедшей даты\r\n    // 1-я фун-я! опред-я разницу между deadline и нашим текущим временем, т.е разницу между датами\r\n    function getTimeRemaining(endtime) {\r\n        let days, hours, minutes, seconds;\r\n        // нам нужно превр-ть строку в нечно осязаемое, испол-м Date.parce\r\n        // получ-и кол-во мс в нашем конеч-м времени до кот-го нам нужно дойти\r\n        // мы в пере-ю t получим разницу между этими датами в кол-ве мс\r\n        const t = Date.parse(endtime) - Date.parse(new Date());\r\n        // добавим обработка прошедшей даты(Lesson 70), опред-м будет ли значение у нас отриц-м, \r\n        // и если оно отриц-е то мы просто вернем нули 000 вместо наших значений\r\n        if (t <= 0) {\r\n            // устан-м знач-е 0 каждой перем-й\r\n            days = 0;\r\n            hours = 0;\r\n            minutes = 0; \r\n            seconds = 0;\r\n        } else {\r\n        // тут нам нужно посч-ть кол-во дней отобр-я в нашем таймере\r\n        // нам нужно взять кол-во мс и / на кол-во мс в одном дне и округлить все это\r\n        //  days = Math.floor() - это округ-е до ближ-го целого\\\r\n        // где 1000 * 60 - кол-во мс в 1мин, еще на * 60 - кол-во в 1 часе, * 24 - кол-во в 1 дне\r\n        // т.е тут (1000 * 60 * 60 * 24) мы получ-м сколько в сутках будем мс\r\n        // и когда мы общее кол-во мс t / на (1000 * 60 * 60 * 24) мы получ-м сколько суток у нас осталось до оконч-я\r\n        // нашей даты ('2020-05-11')\r\n        days = Math.floor( (t/(1000*60*60*24)) );\r\n        // t / на кол-во мс в 1 часе и так мы получим общее кол-во часов остав-ся до таймера\r\n        // далее мы общее кол-во часов что получ-сь (t / 1000 * 60 * 60) делим через % на 24\r\n        // т.е. мы напр. 50 / 24 и получ-м 2 дня, а остаток от деления, т.е. 2 часа, вер-ся и мы его помести к нам на сайт\r\n        // в графу кол-ва часов остав-ся до конца акции\r\n        hours = Math.floor( (t/(1000*60*60) % 24) );\r\n        // и по похожему принципу мы будем считать и далее т.к. нам нужны именно \"хвостики\" а не общее кол-во!\r\n        minutes = Math.floor( (t/1000/60) % 60 );\r\n        // тут нам нужно просто разделить кол-во сек внутри мс\r\n        seconds = Math.floor( (t/1000) % 60 );\r\n        }\r\n        \r\n\r\n        // и что-бы мы могли испол-ть перем-е выше снаружи мы должны их вернуть, при этом мы будем возв-ть объект\r\n        // такой прием часто испол-ся!!!\r\n        return {\r\n            // св-во total будет у нас - общее кол-во мс, куда соот. мы поместим значение t\r\n            // в будущем нам нужна будем перем-я t, т.к. нам нужно знать не закон-ся ли таймер\r\n            'total': t,\r\n            'days': days,\r\n            'hours': hours,\r\n            'minutes': minutes,\r\n            'seconds': seconds\r\n            // в ссылке есть инфа как записать схожие по названию ключи и значения иначе\r\n            // https://attacomsian.com/blog/javascript-object-property-shorthand\r\n        };\r\n    }\r\n\r\n    // тут нам нужно подставить 0 в ячейки с днями и часами, чтобы было 09 дней и тд\r\n    function getZero(num){\r\n        // если пришед-е число от 0-10 тогда подст-м 0\r\n        if (num >= 0 && num < 10) { \r\n            return '0' + num;\r\n        } else {\r\n            return num;\r\n        }\r\n    }\r\n\r\n    // 2-я фун-я! когда у нас уже есть фун-я по расчету времен-х промежутков, напишем фун-ю устанав-ю наш таймер нам на стр-цу\r\n    // для запуска этой фун-и нам понад-ся 2 аргум-та (selector, endtime)\r\n    function setClock(selector, endtime) {\r\n        // и что-бы настроить наш таймер нам нужен блок <div class=\"timer\"> и deadline кот-й мы будем в него перед-ть\r\n        // получ-м все нужные нам элем-ты со страницы\r\n        const timer = document.querySelector(selector),\r\n              days = timer.querySelector('#days'),\r\n              hours = timer.querySelector('#hours'),\r\n              minutes = timer.querySelector('#minutes'),\r\n              seconds = timer.querySelector('#seconds'),\r\n            // где фун-й будет высту-ть updateClock() и запус-я она будет через каждую сек\r\n              timeInterval = setInterval(updateClock, 1000);\r\n\r\n        // запус-м updateClock для инициализации(запустит текущ-ю дату) и отмены \"моргания\" таймера при обновлении страницы\r\n        updateClock();\r\n\r\n        // 3-я фун-я! обновляющая наш таймер каждую секунду, пишем ее внутри 2-й фун-и setClock\r\n        // внутри себя она будет содер-ть 3 самых глав. действия\r\n        function updateClock() {\r\n            // 1. расчет времени что остался прямо на эту секунду и для этого испол. фун-ю getTimeRemaining\r\n            // которрая возвр-т нужный нам объект с данными, где endtime это на дедлайн кот-й мы будем перед-ть в setClock\r\n            const t = getTimeRemaining(endtime);\r\n            // 2. теперь нам нужно поместить на стр-цу расчетные величины что мы получили\r\n            // колич-во дней кот-е мы отобр-м на стр-це\r\n            // и чтобы наш 0 при необ-ть подств-ся испол. фун-ю getZero\r\n            days.innerHTML = getZero(t.days);\r\n            hours.innerHTML = getZero(t.hours);\r\n            minutes.innerHTML = getZero(t.minutes);\r\n            seconds.innerHTML = getZero(t.seconds);\r\n            // и когда эта фун-я запус-ся, она расч-т нужное нам время и на основ-и этих расчетов запишет на стр-цу \r\n            // необ. резул-ты, запуск фун-и будет в константе timeInterval\r\n            // 3. И раз у нас уже есть интервал, то нам его нужно будет рано или поздно остановить\r\n            // и для этого нам нужна будет перем-я t в 'total': t, т.к. в ней есть кол-во мс нужное нам\r\n            // если наше ремя уже вышло, т.е. оно идет в отриц-ю сторону, то таймер мы уже не обновляем\r\n            if (t.total <= 0) {\r\n                // то мы просто будем остан-ть наш таймер\r\n                clearInterval(timeInterval);\r\n            }\r\n        }\r\n    }\r\n    // устанав-м наши часы в фун-и setClock, где 1-й арг-т это наш селектор .timer, \r\n    // а 2-й наш дедлайн, в будущем данные в эту перем-ю могут прих-ть от сервера!\r\n    setClock(id, deadline);\r\n}\r\nexport default timer;","// Lesson 90. Получение данных с сервера. Async/Await (ES8)\r\n// Фун-я postDada настр-т наш запрос, посылает его на сервер(через fetch), получ-т ответ от сервера(удачный или нет) \r\n// и потом транфор-м этот ответ в json. На данном этапе мы имеем асинх-й код и что-бы эта фун-я правильно работала \r\n// и не выдавала ошибок нам нужен как бы \"синх-й\" код, тут нам и поможет констр-я Async/Await(подр-е в коде ниже).\r\n// async - ставит-ся перед функ-й и делает ее асинх-й, а await - значит \"подожди\", т.е. он ставится перед той опрацией(кодом)\r\n// выпол-е кода которой нужно дождаться, например подождать пока не прийдет данные в перем-ю res от сервера в методе fetch.\r\n// Испол-м синтаксис Function Expression, т.е. присв-е фун-и в обычную переменную, где url соот адресс, \r\n// а data - данные кот-е будут постится в этой функ-и\r\nconst postDada = async (url, data) => {\r\n    // Во внутрь перем-й поместим промис кот-й возвр-ся от fetch()\r\n    const res = await fetch(url, {\r\n        method: \"POST\",\r\n        headers: {\r\n            'Content-type': 'application/json'\r\n        },\r\n        // \r\n        body: data\r\n    });\r\n    // В перем-й res у нас будет наход-ся промис, кот-й мы обработ-м уже как json-формат\r\n    // Мы не знаем каким большим будет промис(т.е. объект с данными что вернется) и сколько времени нужно будет чтобы\r\n    // перевести его в обычный объект и чтобы додж-ть выпол-я этой части кода испол-и и тут await перед перем-й res\r\n    return await res.json();\r\n};\r\n\r\n// Созд-м фун-ю для получ-я наших карточек\r\nasync function getResource (url) {\r\n    // Тут мы просто делаем запрос через fetch() и дожидаемся его окончания\r\n    let res = await fetch(url);\r\n    // Promise возвращаемый вызовом fetch() не перейдёт в состояние \"отклонено\" из-за ответа HTTP, т.е. не выдаст ошибку!!!\r\n    // и этот момент нам нужно предусмотреть и сделать спец. условие\r\n    if (!res.ok) {\r\n        // здесь мы познакомимся с объектом ошибки new Error, во внутрь которой () помещаем текст ошибки\r\n        // и чтобы эта ошибка выпала из фун-и есть спец. оператор throw, т.е. мы выкидываем новую ошибку\r\n        throw new Error(`Could not fetch ${url}, status: ${res.status}`);\r\n    }\r\n    // трансфор-м данные получ-е выше с перем-й в обычный json-объект\r\n    return await res.json();\r\n}\r\n\r\nexport {postDada};\r\nexport {getResource};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Заимпортируем все наши js файлы в главный(порядок значения не имеет), тем самым объединив их\r\nimport tabs from './modules/tabs';\r\nimport timer from './modules/timer';\r\nimport modal from './modules/modal';\r\nimport cards from './modules/cards';\r\nimport slider from './modules/slider';\r\nimport calc from './modules/calc';\r\nimport forms from './modules/forms';\r\nimport {openModal} from './modules/modal';\r\n\r\n// Назначаем глобальный обработчик событий\r\nwindow.addEventListener('DOMContentLoaded', () => {  \r\n    // Через опред-й промежуток времени в () поместим фун-ю открытию мод. окна и устан. время его появ-я на сайте\r\n    const modalTimerId = setTimeout(() => openModal('.modal', modalTimerId), 500000); \r\n    // Lesson 101-102 Модули + Webpuck. Т.к. переменные выше явл-ся функциями - вызовем их\r\n    tabs('.tabheader__item', '.tabcontent', '.tabheader__items', 'tabheader__item_active');\r\n    // Установим 2-м аргументом дату дедлайна для таймера\r\n    timer('.timer', '2022-12-08');\r\n    // В аргум-ты запишем нужные нам элементы со стр-цы(откр-е мод.окна)\r\n    modal('[data-modal]', '.modal', modalTimerId);\r\n    cards();\r\n    // Перед-м в слайдер объект с опред-ми настр-ми(как это делается в плагинах)\r\n    slider({\r\n        container: '.offer__slider',\r\n        slide: '.offer__slide',\r\n        nextArrow: '.offer__slider-next',\r\n        prevArrow: '.offer__slider-prev',\r\n        totalCounter: '#total',\r\n        currentCounter: '#current',\r\n        wrapper: '.offer__slider-wrapper',\r\n        field: '.offer__slider-inner'\r\n\r\n    });\r\n    calc();\r\n    forms('form', modalTimerId);\r\n\r\n});\r\n\r\n\r\n\r\n\r\n// Lesson 82 JSON\r\n// JSON.stringify()\r\n// Метод преобразует значение JavaScript в строку JSON, возможно с заменой значений, если указана функция замены,\r\n// или с включением только определённых свойств, если указан массив замены. Синтаксис:\r\n// JSON.stringify(value[, replacer[, space]])\r\n// value - Значение, преобразуемое в строку JSON.\r\n// replacer (Необязательный) - Если является функцией, преобразует значения и свойства по ходу их преобразования в строку; \r\n// если является массивом, определяет набор свойств, включаемых в объект в окончательной строке.\r\n// space (Необязательный) - Делает результат красиво отформатированным (расставляя пробелы).\r\n\r\n// Lesson 84 \r\n// Объект FormData позволяет создать набор пар ключ/значение и передать их, используя XMLHttpRequest. Объект FormData \r\n// предназначен для передачи данных форм, однако может быть использован для передачи пар ключ/значение независимо от форм. \r\n// Данные передаются в том же формате, как и данные, передаваемые методом submit() формы\r\n// В html в <input> в форме обязат-но нужно прописывать имя (name=\"name\")! Что-бы не было ошибок при работе с этим объектом\r\n\r\n// .textContent\r\n// Позволяет задавать или получать текстовое содержимое элемента и его потомков.\r\n\r\n// .reset()\r\n// очищаем данные в полях input после отправки\r\n\r\n// Lesson 83\r\n// XMLHttpRequest \r\n// Это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки \r\n// страницы. Мы можем загружать/скачивать файлы, отслеживать прогресс и многое другое.\r\n// На сегодняшний день не обязательно использовать XMLHttpRequest, так как существует другой, более современный метод fetch.\r\n// XMLHttpRequest()\r\n// Конструктор XMLHttpRequest() создаёт новый объект XMLHttpRequest. Для отправки HTTP-запроса нужно создать \r\n// XMLHttpRequest-объект, открыть URL и отправить запрос. После выпол-я запроса можно получить и обраб-ть тело и статус ответа.\r\n// XMLHttpRequest имеет два режима работы: синхронный и асинхронный.\r\n// Синтаксис: const myRequest = new XMLHttpRequest();\r\n//          Его метод open()\r\n// Этот метод обычно вызывается сразу после new XMLHttpRequest. В него передаются основные параметры запроса:\r\n// - method – HTTP-метод. Обычно это \"GET\" или \"POST\". \"GET\" для получ-я данных от сервера, \"POST\" для отправ-я данных на сервер.\r\n// - URL – URL, куда отправляется запрос: строка, может быть и объект URL. Тут путь нужно формир-ть относит-но HTML\r\n// - async – если указать false, тогда запрос будет выполнен синхронно, это мы рассмотрим чуть позже. \r\n// Синхронный код идет по порядку, т.е. код долго выпол-ся то код ниже будет ее ждать.\r\n// Асинхронный работает иначе, он не блокирует остальной код, в основном испол-ся именно он!\r\n// И по умолчанию Ajax-запросы являются асинхронным кодом\r\n// - login, - password – логин и пароль для базовой HTTP-авторизации (если требуется). Пример:\r\n//  request.open(method, url, async, login, password);\r\n// Заметим, что вызов open, вопреки своему названию, не открывает соединение. Он лишь конфигурирует запрос, но непосредственно \r\n// отсылается запрос только лишь после вызова send.\r\n//          Его HTTP-заголовки\r\n// XMLHttpRequest умеет как указывать свои заголовки в запросе, так и читать присланные в ответ.\r\n// Для работы с HTTP-заголовками есть 3 метода:\r\n// - setRequestHeader(name, value);\r\n// Устанавливает заголовок запроса с именем name и значением value. Например:\r\n// request.setRequestHeader('Content-Type', 'application/json');\r\n// - getResponseHeader(name);\r\n// Возвращает значение заголовка ответа name (кроме Set-Cookie и Set-Cookie2). Например:\r\n// request.getResponseHeader('Content-Type');\r\n// - getAllResponseHeaders();\r\n// Возвращает все заголовки ответа, кроме Set-Cookie и Set-Cookie2.\r\n//           Послать запрос.\r\n// request.send([body])\r\n// Этот метод устанавливает соединение и отсылает запрос к серверу. Необязательный параметр body содержит тело запроса.\r\n//          Когда мы уже отправили запрос, далее с ним нужно что-то делать, когда прийдет ответ от сервера\r\n// для этого есть разл-е св-ва: \r\n// - status (404 и тд), есть отдел-й Список кодов состояния HTTP(в ссылках к уроку)\r\n// - statusText: 404 Not Found («не найдено»)\r\n// - response - это будет наш ответ от сервера, это тот ответ что задал backend-разработчик и мы будем испол-ть на клиенте\r\n// - readyState - это текущее сост-е нашего запроса\r\n// Свойство XMLHttpRequest.readyState возвращает текущее состояние объекта XMLHttpRequest. Объект request может иметь следующие состояния:\r\n// Значение\tСостояние\t        Описание\r\n//  0\t    UNSENT\t            Объект был создан. Метод open() ещё не вызывался.\r\n//  1\t    OPENED\t            Метод open() был вызван.\r\n//  2\t    HEADERS_RECEIVED\tМетод send() был вызван, доступны заголовки (headers) и статус.\r\n//  3\t    LOADING\tЗагрузка;   responseText содержит частичные данные.\r\n//  4\t    DONE\t            Операция полностью завершена.\r\n// И на основании этих св-в мы будем сторить дальнейшее взаимод-е\r\n//          У объекта XMLHttpRequest также есть события кот-е относ-ся к нему. События на request, чтобы получить ответ.\r\n// Три наиболее используемых события:\r\n// - load – происходит, когда получен какой-либо ответ, включая ответы с HTTP-ошибкой, например 404.\r\n// Изменения в состоянии объекта запроса генерируют событие readystatechange:\r\n// - error – когда запрос не может быть выполнен, например, нет соединения или невалидный URL.\r\n// - progress – происходит периодически во время загрузки ответа, сообщает о прогрессе.\r\n//          Отмена запроса\r\n// Если мы передумали делать запрос, можно отменить его вызовом request.abort():\r\n\r\n\r\n// Lesson 85\r\n// getAttribute()\r\n// возвращает значение указанного атрибута элемента. Если элемент не содержит данный атрибут, \r\n// могут быть возвращены null или \"\" (пустая строка);\r\n\r\n// insertAdjacentElement()\r\n// Метод insertAdjacentElement() добавляет переданный элемент в DOM-дерево относительно элемента, вызвавшего метод. Синтаксис:\r\n// targetElement.insertAdjacentElement(position, element);\r\n// position: 'beforebegin': перед самим элементом targetElement.\r\n// 'afterbegin': внутри элемента targetElement, перед его первым потомком.\r\n// 'beforeend': внутри элемента targetElement, после его последнего потомка.\r\n// 'afterend': после самого элемента targetElement.\r\n// element: Элемент, добавляемый в DOM-дерево.\r\n// Возвращаемое значение: Метод возвращает добавляемый элемент, либо null, если добавление элемента завершилось ошибкой.\r\n\r\n// Lesson 87 Fetch API\r\n//      Fetch API предоставляет интерфейс JavaScript для работы с запросами и ответами HTTP. Он также предоставляет глобальный \r\n// метод fetch() (en-US), который позволяет легко и логично получать ресурсы по сети асинхронно.\r\n// Подобная функциональность ранее достигалась с помощью XMLHttpRequest. Fetch представляет собой лучшую альтернативу, \r\n// которая может быть легко использована другими технологиями, такими как Service Workers. Fetch также обеспечивает \r\n// единое логическое место для определения других связанных с HTTP понятий, такие как CORS и расширения для HTTP.\r\n// Обратите внимание, fetch спецификация отличается от jQuery.ajax() в основном в двух пунктах:\r\n// - !!! Promise возвращаемый вызовом fetch() не перейдёт в состояние \"отклонено\" из-за ответа HTTP, который считается ошибкой, \r\n// даже если ответ HTTP 404 или 500. Вместо этого, он будет выполнен нормально (с значением false в статусе ok ) \r\n// и будет отклонён только при сбое сети или если что-то помешало запросу выполниться.\r\n// - По умолчанию, fetch не будет отправлять или получать cookie файлы с сервера, в результате чего запросы будут осуществляться \r\n// без проверки подлинности, что приведёт к неаутентифицированным запросам, если сайт полагается на проверку пользовательской \r\n// сессии (для отправки cookie файлов в аргументе init options должно быть задано значение свойства credentials отличное от \r\n// значения по умолчанию omit).\r\n//      fetch()\r\n// Есть несколько способов делать сетевые запросы и получать информацию с сервера.\r\n// Метод fetch() Базовый синтаксис:\r\n// let promise = fetch(url, [options])\r\n// url – URL для отправки запроса.\r\n// options – дополнительные параметры: метод, заголовки и так далее.\r\n// Без options это простой GET-запрос, скачивающий содержимое по адресу url.\r\n// Браузер сразу же начинает запрос и возвращает промис, который внешний код использует для получения результата.\r\n//      Во-первых, promise выполняется с объектом встроенного класса Response в качестве результата, как только сервер \r\n// пришлёт заголовки ответа. На этом этапе мы можем проверить статус HTTP-запроса и определить, выполнился ли он успешно, \r\n// а также посмотреть заголовки, но пока без тела ответа.\r\n// Промис завершается с ошибкой, если fetch не смог выполнить HTTP-запрос, например при ошибке сети или если нет такого сайта. \r\n// HTTP-статусы 404 и 500 не являются ошибкой. Мы можем увидеть HTTP-статус в свойствах ответа:\r\n// status – код статуса HTTP-запроса, например 200.\r\n// ok – логическое значение: будет true, если код HTTP-статуса в диапазоне 200-299.\r\n// Например:\r\n// let response = await fetch(url);\r\n// if (response.ok) { // если HTTP-статус в диапазоне 200-299\r\n//    получаем тело ответа (см. про этот метод ниже)\r\n//   let json = await response.json();\r\n// } else {\r\n//   alert(\"Ошибка HTTP: \" + response.status);\r\n// }\r\n//      Во-вторых, для получения тела ответа нам нужно использовать дополнительный вызов метода.\r\n// Response предоставляет несколько методов, основанных на промисах, для доступа к телу ответа в различных форматах:\r\n// response.text() – читает ответ и возвращает как обычный текст,\r\n// response.json() – декодирует ответ в формате JSON,\r\n// response.formData() – возвращает ответ как объект FormData (разберём его в следующей главе),\r\n// response.blob() – возвращает объект как Blob (бинарные данные с типом),\r\n// response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневое представление бинарных данных),\r\n// помимо этого, response.body – это объект ReadableStream, с помощью которого можно считывать тело запроса по частям. \r\n// Мы рассмотрим и такой пример несколько позже.\r\n// Например, получим JSON-объект с последними коммитами из репозитория на GitHub:\r\n// let url = 'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits';\r\n// let response = await fetch(url);\r\n// let commits = await response.json(); // читаем ответ в формате JSON\r\n// alert(commits[0].author.login);\r\n// ! Важно запомнить что: Promise возвращаемый вызовом fetch() не перейдёт в состояние \"отклонено\" из-за ответа HTTP, \r\n// который считается ошибкой, даже если ответ HTTP 404 или 500.  Вместо этого, он будет выполнен нормально \r\n// (с значением false в статусе ok ) и будет отклонён только при сбое сети или если что-то помешало запросу выполниться.\r\n// Главное для этого метода что он вообще смог сделать этот запрос\r\n\r\n// Итого\r\n// Типичный запрос с помощью fetch состоит из двух операторов await: Или, без await:\r\n//      Параметры ответа:\r\n// response.status – HTTP-код ответа, т.е. тот статус что вернул нам сервер(404 и тд)\r\n// response.ok – true, т.е. все хорошо, если статус ответа в диапазоне 200-299.\r\n// response.headers – похожий на Map объект с HTTP-заголовками.\r\n//      Методы для получения тела ответа:\r\n// response.text() – возвращает ответ как обычный текст,\r\n// response.json() – преобразовывает ответ в JSON-объект,\r\n// response.formData() – возвращает ответ как объект FormData (кодировка form/multipart, см. следующую главу),\r\n// response.blob() – возвращает объект как Blob (бинарные данные с типом),\r\n// response.arrayBuffer() – возвращает ответ как ArrayBuffer (низкоуровневые бинарные данные),\r\n//      Опции fetch, которые мы изучили на данный момент:\r\n// method – HTTP-метод,\r\n// headers – объект с запрашиваемыми заголовками (не все заголовки разрешены),\r\n// body – данные для отправки (тело запроса) в виде текста, FormData, BufferSource, Blob или UrlSearchParams.\r\n\r\n\r\n// Lesson 89 - работа с JSON-Server\r\n// Команда запуска JSON-Server в терминале VS-code на Windows 10: npx json-server db.json\r\n// после запуска сервера командой: npx json-server db.json  мы увидем такие пути куда можно делать запросы в терминале:\r\n// Resources\r\n// http://localhost:3000/menu\r\n// http://localhost:3000/requests\r\n// Home\r\n// http://localhost:3000\r\n// В будущем нужно будет запускать и локальный сервер и JSON-Server для работы с этим и др. проектами!\r\n\r\n\r\n// Lesson 90. Получение данных с сервера. Async/Await (ES8)\r\n// Async/await\r\n// async - ставится перед функцией и говорит что внутри будет асинх-й код, эта функция всегда будет возвращать промис. \r\n// Ключевое слово async перед функцией гарантирует, что эта функция в любом случае вернёт промис.\r\n// await - можно использовать только внутри async-функций и ставит-ся только перед теми операциами, т.е перед тем кодом, \r\n// например перед fetch(), выпол-е кода которых нужно дожд-ся(например подождать пока не прийдут данные от сервера в методе fetch)\r\n// Оперераторы async/await всегда испол-ся в паре!\r\n// После отправки данных с формы мы увидим их не только в консоли но и в нашем db.json в объекте \"requests\":\r\n\r\n// Object.entries()\r\n// Метод Object.entries(obj) – возвращает массив пар [ключ, значение].\r\n// Object.fromEntries\r\n// Используем Object.fromEntries(array) на результате, чтобы преобразовать его обратно в объект.\r\n\r\n// Error\r\n// Конструктор Error создаёт объект ошибки. Экземпляры объекта Error выбрасываются при возникновении ошибок во время \r\n// выполнения. Объект Error также может использоваться в качестве базового для пользовательских исключений. \r\n// throw\r\n// Инструкция throw позволяет генерировать исключения, определяемые пользователем, т.е. позволяет \r\n// выкидывать текст ошибки выше. Например:\r\n// throw \"Error2\"; // генерирует исключение, значением которого является строка\r\n\r\n// Деструктуризация\r\n// Деструктурирующее присваивание в JavaScript — это изящный способ извлечения значений из массивов и объектов, при котором \r\n// в полной мере реализуется принцип DRY (англ. Don’t repeat yourself — «Не повторяйся»).\r\n// Т.е. - это когда мы из объекта(напр. db.json) вытаск-м отдел-е св-ва в качестве отдел-й перем-й {img, altimg}\r\n\r\n\r\n// Lesson 91. Что такое библиотеки. Библиотека axios. CDN\r\n//      CDN\r\n// CDN (Content Delivery Network - сеть доставки контента) - это группа серверов, расположенных во многих местах. \r\n// Эти сервера хранят дубликаты данных, чтобы сервера могли выполнять запросы данных на основе того, какие сервера ближе всего к \r\n// конечным пользователям. CDN увеличивают скорость доступа к сервису уменьшая влияние высокого трафика.\r\n//      Axios\r\n// Axios — это широко известная JavaScript-библиотека. Она представляет собой HTTP-клиент, основанный на промисах и \r\n// предназначенный для браузеров и для Node.js. Он изоморфный (= он может работать в браузере и node.js \r\n// с той же базой кодов). На стороне сервера он использует нативный node.js http-модуль, тогда как на стороне клиента (браузер) \r\n// он использует XMLHttpRequests. \r\n// Особенности:\r\n// 1. Делает XMLHttpRequests запросы из браузера; 2. Делает http запросы из node.js;\r\n// 3. Поддерживает Promise API; 4. Перехватывает запросы и ответы;\r\n// 5. Преобразовывает данные запроса и ответа; 6. Отменяет запросы;\r\n// 7. Автоматическое преобразование для JSON-данных; 8. Поддержка на стороне клиента для защиты от XSRF\r\n\r\n\r\n// Lesson 92=93. Слайдер \r\n//      window.getComputedStyle()\r\n// Метод Window.getComputedStyle() возвращает объект, содержащий значения всех CSS-свойств элемента, полученных после \r\n// применения всех активных таблиц стилей, и завершения базовых вычислений значений, которые они могут содержать. \r\n// Некоторые CSS-свойства доступны через API, предоставляемые объектом, или индексацию по именам CSS-свойств.\r\n// Синтаксис:\r\n// var style = window.getComputedStyle(element [, pseudoElt]);\r\n// element - Element, свойства которого необходимо получить.\r\n// pseudoElt (Необязательный) - Строка указывающая на найденный псевдо-элемент. Опускается (или null) для не псевдо-элементов.\r\n// Возвращённый style живой CSSStyleDeclaration объект, который обновляется автоматически когда элемент стилей изменяется.\r\n// Выводы: Метод Window.getComputedStyle() предоставляет все значения CSS-свойств элементов после применения текущей таблицы \r\n// стилей или базового расчёта каких-либо значений, которые могут быть.\r\n\r\n// .slice()\r\n// Метод slice() извлекает часть строки и возвращает новую строку без изменения оригинальной строки.\r\n\r\n\r\n// Lesson 97-98. Создаем калькулятор на сайте\r\n//      Формула расчета базовой нормы калорий:\r\n// для мужчин: BMR = 88.36 + (13.4 x вес, кг) + (4.8 х рост, см) – (5.7 х возраст, лет)\r\n// для женщин: BMR = 447.6 + (9.2 x вес, кг) + (3.1 х рост, cм) – (4.3 х возраст, лет)\r\n// Коэффициенты активности при расчете нормы калорий(прописан в data-атрибутах):\r\n//       Минимальный уровень активности — 1.2\r\n// Низкий уровень активности — 1.375\r\n// Средний уровень активности — 1.55\r\n// Высокий уровень — 1.725\r\n// Очень высокий —  1.9\r\n\r\n// Событие: input\r\n// Событие input срабатывает каждый раз при изменении значения.\r\n// В отличие от событий клавиатуры, оно работает при любых изменениях значений, даже если они не связаны с \r\n// клавиатурными действиями: вставка с помощью мыши или распознавание речи при диктовке текста.\r\n// Если мы хотим обрабатывать каждое изменение в <input>, то это событие является лучшим выбором.\r\n\r\n// Конструкция \"switch\"\r\n// Конструкция switch заменяет собой сразу несколько if и имеет один или более блок case и необ-й блок default.\r\n// switch(x) {\r\n//     case 'value1':  // if (x === 'value1')\r\n//       [break]\r\n//     case 'value2':  [break]\r\n//     default: [break]\r\n// }\r\n\r\n// Math.round()\r\n// Метод Math.round() возвращает число, округлённое к ближайшему целому.\r\n\r\n\r\n\r\n// Команда запуска JSON-Server в терминале VS-code на Windows 10: npx json-server db.json\r\n// npm install webpack webpack-cli --save-dev - команда по установке webpack!\r\n// webpack.config.js - это наш конфигурац-й файл\r\n// Далее выполним: npx webpack\r\n"],"names":[],"sourceRoot":""}