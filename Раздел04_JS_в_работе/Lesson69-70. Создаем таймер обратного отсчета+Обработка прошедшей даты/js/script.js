// сначала назначаем глобальный обработчик событий
window.addEventListener('DOMContentLoaded', () => {
    //   Lesson 64. Tabs

    // получ-м перем-е с которыми мы будем взаимод-ть
    const tabs = document.querySelectorAll('.tabheader__item'),
          tabsContent = document.querySelectorAll('.tabcontent'),
    // родитель кот-й будет содер-ть все наши табы(тема делегирование событий)
          tabsParent = document.querySelector('.tabheader__items');

    // делаем фун-ю(она может быть универсальной) где скрываем все ненуж-е нам табы!
    function hideTabContent() {
        // т.к. это псевдомассив нам его нужно перебрать, где item - это каждый отдел-й контент
        tabsContent.forEach(item => {
                // т.е. добав-м к item css стиль - display = 'none', кот-й скрывает контент
                // item.style.display = 'none';
            // чтобы добавить анимацию при перек-и табов нам нужны будут css классы при перек-и, а не inline стили испол-е выше
            // класс 'hide' прячет контент (display = 'none')
            // класс 'show' показ-т контент (display = 'block')
            // класс 'fade' у нас отвеч-т за анимацию
            item.classList.add('hide');
            item.classList.remove('show', 'fade');
        });
        // убер-м класс активности у всех табов которые нам не нужны будут
        tabs.forEach(item => {
            item.classList.remove('tabheader__item_active');
        });
    }

    // теперь делаем фун-ю которая будет показывать нам таб-контент(она может быть универсальной)!
    // где i - это элемент(номер) к кот-му мы обращ-ся и кот-й нужно будет показать.
    // в ES6 есть такой функционал где мы можем устан-ть значение по умолчанию уже в нашей фун-и! 
    // Т.е. если мы выз-м фун-ю без аргум-та, то у нас вместо i будет подст-ся 0. Т.е. i мы сразу присв-м 0 !
    function showtabContent(i = 0) {
            // испол-м inline стили при перекл-и, но также в перек-и часто испол-т и классы(далее рассмотрим)
            // tabsContent[i].style.display = 'block';
        // для того что бы у нас работали классы и соот. анимация заменим пример выше на:
        tabsContent[i].classList.add('show', 'fade');
        tabsContent[i].classList.remove('hide');
        tabs[i].classList.add('tabheader__item_active');
    }
    // чтобы фун-и выше заработали не забываем их вызывать после!
    hideTabContent();
    // арг-м в() устан-м в фун-и по умолчанию, т.е. 0, в ES6 функ-и мы можем сразу присв-ть 0, (i = 0)
    showtabContent();

    // испол-я делегирование, созд-м событие на клик
    tabsParent.addEventListener('click', (event) => {
        // если мы часто будем испол-ть событие event.target мы можем опред-ть его в перем-ю
        const target = event.target;
        if (target && target.classList.contains('tabheader__item')) {
            // методом перебора делаем расп-е куда кликнул польз-ль и подст-м соот. по номеру элемент для показа
            // где item - это каждый таб что бы будем передавать, а i - это номер элемента по порядку(согласно синтаксису метода)
            tabs.forEach((item, i) => {
                // если target(тот элемент в кот-й мы кликнули) будет совпадать с элементом что мы перебираем
                if(target == item) {
                    // вызыв-м 2 фун-и т.к. при перекл-и мы должны скрыть остальные и ост-ть только нужную
                    hideTabContent();
                    // где в i хранит-ся нужный нам номер по порядку
                    showtabContent(i);
                }
            });
        }
    });


    // Lesson 69. Timer + Lesson 70. Обработка прошедшей даты
    // в перем-ю поместим дату в виде строки, это будет наша отправ-я точка
    const deadline = '2021-08-08';

    // 1-я фун-я! опред-я разницу между deadline и нашим текущим временем, т.е разницу между датами
    function getTimeRemaining(endtime) {
        let days, hours, minutes, seconds;
        // нам нужно превр-ть строку в нечно осязаемое, испол-м Date.parce
        // получ-и кол-во мс в нашем конеч-м времени до кот-го нам нужно дойти
        // мы в пере-ю t получим разницу между этими датами в кол-ве мс
        const t = Date.parse(endtime) - Date.parse(new Date());
        // добавим обработка прошедшей даты(Lesson 70), опред-м будет ли значение у нас отриц-м, 
        // и если оно отриц-е то мы просто вернем нули 000 вместо наших значений
        if (t <= 0) {
            // устан-м знач-е 0 каждой перем-й
            days = 0;
            hours = 0;
            minutes = 0; 
            seconds = 0;
        } else {
        // тут нам нужно посч-ть кол-во дней отобр-я в нашем таймере
        // нам нужно взять кол-во мс и / на кол-во мс в одном дне и округлить все это
        //  days = Math.floor() - это округ-е до ближ-го целого\
        // где 1000 * 60 - кол-во мс в 1мин, еще на * 60 - кол-во в 1 часе, * 24 - кол-во в 1 дне
        // т.е тут (1000 * 60 * 60 * 24) мы получ-м сколько в сутках будем мс
        // и когда мы общее кол-во мс t / на (1000 * 60 * 60 * 24) мы получ-м сколько суток у нас осталось до оконч-я
        // нашей даты ('2020-05-11')
        days = Math.floor( (t/(1000*60*60*24)) );
        // t / на кол-во мс в 1 часе и так мы получим общее кол-во часов остав-ся до таймера
        // далее мы общее кол-во часов что получ-сь (t / 1000 * 60 * 60) делим через % на 24
        // т.е. мы напр. 50 / 24 и получ-м 2 дня, а остаток от деления, т.е. 2 часа, вер-ся и мы его помести к нам на сайт
        // в графу кол-ва часов остав-ся до конца акции
        hours = Math.floor( (t/(1000*60*60) % 24) );
        // и по похожему принципу мы будем считать и далее т.к. нам нужны именно "хвостики" а не общее кол-во!
        minutes = Math.floor( (t/1000/60) % 60 );
        // тут нам нужно просто разделить кол-во сек внутри мс
        seconds = Math.floor( (t/1000) % 60 );
        }
        

        // и что-бы мы могли испол-ть перем-е выше снаружи мы должны их вернуть, при этом мы будем возв-ть объект
        // такой прием часто испол-ся!!!
        return {
            // св-во total будет у нас - общее кол-во мс, куда соот. мы поместим значение t
            // в будущем нам нужна будем перем-я t, т.к. нам нужно знать не закон-ся ли таймер
            'total': t,
            'days': days,
            'hours': hours,
            'minutes': minutes,
            'seconds': seconds
            // в ссылке есть инфа как записать схожие по названию ключи и значения иначе
            // https://attacomsian.com/blog/javascript-object-property-shorthand
        };
    }

    // тут нам нужно подставить 0 в ячейки с днями и часами, чтобы было 09 дней и тд
    function getZero(num){
        // если пришед-е число от 0-10 тогда подст-м 0
        if (num >= 0 && num < 10) { 
            return '0' + num;
        } else {
            return num;
        }
    }

    // 2-яя фун-я! когда у нас уже есть фун-я по расчету времен-х промежутков, напишем фун-ю устанав-ю наш таймер нам на стр-цу
    // для запуска этой фун-и нам понад-ся 2 аргум-та (selector, endtime)
    function setClock(selector, endtime) {
        // и что-бы настроить наш таймер нам нужен блок <div class="timer"> и deadline кот-й мы будем в него перед-ть
        // получ-м все нужные нам элем-ты со страницы
        const timer = document.querySelector(selector),
              days = timer.querySelector('#days'),
              hours = timer.querySelector('#hours'),
              minutes = timer.querySelector('#minutes'),
              seconds = timer.querySelector('#seconds'),
            // где фун-й будет высту-ть updateClock() и запус-я она будет через каждую сек
              timeInterval = setInterval(updateClock, 1000);

        // запус-м updateClock для инициализации(запустит текущ-ю дату) и отмены "моргания" таймера при обновлении страницы
        updateClock();

        // 3-я фун-я! обновляющая наш таймер каждую секунду, пишем ее внутри 2-й фун-и setClock
        // внутри себя она будет содер-ть 3 самых глав. действия
        function updateClock() {
            // 1. расчет времени что остался прямо на эту секунду и для этого испол. фун-ю getTimeRemaining
            // которрая возвр-т нужный нам объект с данными, где endtime это на дедлайн кот-й мы будем перед-ть в setClock
            const t = getTimeRemaining(endtime);
            // 2. теперь нам нужно поместить на стр-цу расчетные величины что мы получили
            // колич-во дней кот-е мы отобр-м на стр-це
            // и чтобы наш 0 при необ-ть подств-ся испол. фун-ю getZero
            days.innerHTML = getZero(t.days);
            hours.innerHTML = getZero(t.hours);
            minutes.innerHTML = getZero(t.minutes);
            seconds.innerHTML = getZero(t.seconds);
            // и когда эта фун-я запус-ся, она расч-т нужное нам время и на основ-и этих расчетов запишет на стр-цу 
            // необ. резул-ты, запуск фун-и будет в константе timeInterval
            // 3. И раз у нас уже есть интервал, то нам его нужно будет рано или поздно остановить
            // и для этого нам нужна будет перем-я t в 'total': t, т.к. в ней есть кол-во мс нужное нам
            // если наше время уже вышло, т.е. оно идет в отриц-ю сторону, то таймер мы уже не обновляем
            if (t.total <= 0) {
                // то мы просто будем остан-ть наш таймер
                clearInterval(timeInterval);
            }
        }
    }
    // устанав-м наши часы в фун-и setClock, где 1-й арг-т это наш селектор .timer, 
    // а 2-й наш дедлайн, в будущем данные в эту перем-ю могут прих-ть от сервера!
    setClock('.timer', deadline);

});