'use strict';
// Lesson 76. Контекст вызова функции. This. Методы call(), apply(), bind()

// Для доступа к информации внутри объекта метод может использовать ключевое слово this.
// Значение this – это объект «перед точкой», который использовался для вызова метода.
let user = {
  name: "Джон",
  age: 30,
  sayHi() {
    // this - это "текущий объект"
    console.log(this.name);  // Джон
  }
};
user.sayHi(); 
// Ранее мы стыкались с this только в варианте с примерет выше, но это ключ. слово в JS может намного больше.

// Вызов — это исполнение кода тела функции. Например, вызовом функции parseInt будет parseInt('15').
// Контекстом вызова является значение this в теле функции.
// Область видимости функции — это набор переменных, объектов и функций, к которым можно получить доступ из тела функции.
// В JavaScript this — это текущий контекст исполнения функции. Поскольку функцию можно вызвать четырьмя способами:

// 1-й
function showThis(a, b) {
  console.log(this);   // Window (если 'use strict'; не испол-ся) / undefined (если 'use strict'; испол-ся)
  // в 1-м случае this=Window, это когда мы испол-м в фун-и контекс, то этот контекст будет ссылаться на глоб-й объект Window
  // во 2-м случае this=undefined
  function sum() {
    // посмотрим что внутри фун-и sum()
    console.log(this); // undefined ('use strict'; вкл)
    // undefined - т.к не смотря на то что у нас испол-ся фун-я внутри фун-и контекст вызова от этого не меняется

    // эта фун-я должна возвр-ть сумму 2-х аргум-в
    // return this.a + this.b;   // будет ошибка
    // и чтобы получить рез-т нам нужно применить замыкание, фун-я sum() при этом не найдя арг-в у себя 
    // пойдет на уровень выше к родит-й фун-и showThis()
    return a + b;   // 9
  }
  // посмотрим результат работы фун-и выше
  console.log(sum());
}
showThis(4, 5);

// 2-й Методы в объекте. Обычные методы это тоже функции
const obj = {
  a: 20,
  b: 15,
  sum: function() {
    // console.log(this);   // { a: 20, b: 15, sum: [Function: sum] }
    // добавим еще одну фун-ю в метод
    function shout() {
      console.log(this);   // undefined
    }
    // вызовем эту фун-ю внутри метода
    shout();
    // в рез-те мы получим в консоле undefined, т.к. это простой вызов фун-и, он уже не относ-ся к методу
    // это уже не метод объекта, а просто фун-я кот-я запус-я внутри метода, поэтому контекст вызова она просто потеряла
    // ситуация схожая как раз с 1-м пунктом: если 'use strict' - undefined
  }
};
// вызываем этот метод и в консоле выше получ-м объект с методом внутри
obj.sum();
// если мы испол-м метод внутри объекта, то контекст вызова всегда будет ссыл-ся на этот объект(obj)

// 3-й Испол-м конструкторы фун-й(пример из пред-го урока)
// Когда фун-я конст-р будет вызвана она создаст новый объект
function User(name, id) {
  // когда мы запис-м св-во нам нужно обрат-я к чему-то, новосоз-му к объекту(т.е вместо this у нас будет объект ivan)
  // и когда мы созд-м новый объект мы запис-м ему новое св-во и в св-во .name мы перед-м то знач-е котор-е 
  // мы передали при создании объекта ivan, а именно 'Ivan'
  this.name = name;
  console.log(name);  // Ivan Dima
  this.id = id;
  this.human = true;
  this.hello = function() {
      console.log(`Hello ${this.name}, your age is ${this.id} year`);   // Hello Dima, your age is 37 year   
  };
}
let ivan = new User('Ivan', 28);
let dima = new User('Dima', 37);
// запустим метод .hello
dima.hello();

// 4. Ручное присвоение this любой функции
function sayNames(surname) {
  console.log(this);  // {name: 'Nika'} {name: 'Nika'}
  console.log(this.name + surname);  // NikaKabl1986
}
const user3 ={
  name: 'Nika'
};
// sayNames.call(user3);
// sayNames.apply(user3);
// Что-бы фун-я sayNames() могла отобразить св-ва в объекте user3 испол-м метод .call, и во внутрь мы передаем 
// контекст вызова который мы хотим передать в фун-ю.
// Метод call() вызывает функцию с указанным значением this и индивидуально предоставленными аргументами.
// Метод apply() вызывает фун-ю с указ-м значением this и аргументами, предостав-и в виде массива (либо массивоподобного объекта).
// Синтаксис этой функции практически полностью идентичен функции apply(), фундаментальное различие между ними заключается в том, 
// что функция call() принимает список аргументов, в то время, как функция apply() - одиночный массив аргументов.
// Больше различий нет, т.к. делают они одно и тоже.
// В результате фун-я sayNames() преоб-т свой контекст благодаря испол-ю методов call() и apply()
// Этими методами мы как бы говорим функ-и заработать на объекте user3 и испол-ть его данные!
// Аргументы в эти методы перед-ся просто через , 
sayNames.call(user3, 'Kabl');       // NikaKabl
// В случае с .apply() перед-м мы в него массивы с данными
sayNames.apply(user3, ['Kabl1986'], ['Kabl1984']);  // NikaKabl1986

// есть и 3-й вариант ручного присв-я контекста, метод .bind(), он уже созд-т новую(важно!) фун-ю связан-ю с опред-м контекстом
function count(num) {
  // здесь нам пока не хватает контекста вызова(в this) которое могло бы * на какое-то число(кот-е будет передано при вызове)
  // т.е. в this у нас пом-ся 2, а num перед-ся в фун-ю double
  return this * num;
}
// Метод bind() создаёт новую функцию, которая при вызове устан-т в качестве контекста выполнения this предост-е значение.
// В эту перем-ю мы поместим !новую фун-ю. Эта фун-я будет удваивать любое число пришедшее в неё
const double = count.bind(2);
// в фун-ю double уже помещ-м число кот-е хотим удвоить
console.log(double(3));   // 6
console.log(double(13));  // 26
// Т.е. double у нас это уже новая фун-я у которой есть жестко привязанный новый контекст(у нас это 2 кот-я пер-я в this)
// И теперь в double мы можем перед-ть всегда один аргумент кот-й будет удваив-ся! 
// И такой метод мы часто будем встречать при работе в будущем, напр. с react!!!


// Из написанного выше важно запомнить!!!
// 1. Обычная функ-я: this = window, но если 'use strict' - undefined
// 2. Контекст у методов объекта - сам объект
// 3. this в конструкторах и классах = это новый экземпляр объекта, важно запомнить!!! 
// Т.к. в будущем с таким поведенеим мы часто будем стыкаться работая с фреймворками и тд
// 4. Ручная привязка this: методы call, apple, bind


// испол-м примеры выше на реал. задаче, например на обработчике событий
const btn = document.querySelector('button');
btn.addEventListener('click', function() {
  // контекстом вызова у нас будет сам элемент на котором произошло событие, так работает в варианте с function()
  console.log(this);  // <button class="btn">Push</button>
  // т.е. this в этом случае у нас будет что и event.target, последний испол-ся чаще!
  // перекрасим кнопку в красный при нажатии
  this.style.backgroundColor = 'red';
  // event.target.style.backgroundColor = 'red';
});
// Функ-ю выше можно переписать и на стрел-ю, но вместо this тогда нужно испо-ть event.target


// Есть еще важная вещь которую нужно помнить, у стрелочной фун-и нет своего контекста вызова!
// Она всегда будет его брать у своего родителя!
const objElement = {
  num: 5,
  sayNumber: function() {
    const say = () => {
      console.log(this);   // {num: 5, sayNumber: ƒ}
      console.log(this.num);  // 5
    };
    say();
  }
};
objElement.sayNumber();
// в примере выше у нас получается след-е, т.к. у стрел-й фун-и say() не своего контекста вызова, она будет брать его
// у своего родителя, метода sayNumber, у метода контекст всегда ссылается на объект в кот-м он существует
// соот. this будет ссылаться на сам объект objElement, это очень важно запомнить!

// Стрел-я фун-я создана для укорачивания нашего кода
const double2 = (a) => {
  return a * 2;
};
// и запись выше мы можем переписать в 1 строчку! Если фун-я может пом-ся в 1 строчку то клыч. слово return можно не ставить
// оно подставится автоматом!
const double3 = (a) => a * 2;
// Если такая фун-я принимает только 1 аргумент, но она может быть записана без ()
const double4 = a => a * 2;
console.log(double4(8));  // 16
