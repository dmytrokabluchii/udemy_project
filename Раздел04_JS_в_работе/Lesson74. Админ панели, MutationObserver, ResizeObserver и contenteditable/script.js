'use strict';
// Lesson 74 MutationObserver, ResizeObserver и contenteditable

// MutationObserver – это встроенный объект, наблюдающий за DOM-элементом и запускающий колбэк в случае изменений.
// Синтаксис: Сначала мы создаём наблюдатель за изменениями с помощью колбэк-функции:
// let observer = new MutationObserver(callback);
// callback - Вызывается при каждом изменении DOM-элемента. Наблюдатель вызывает данную функцию с двумя аргументами. 
// Первым аргументом является массив объектов MutationRecord, вторым аргументом является экземпляр MutationObserver.

// Потом прикрепляем его к DOM-узлу, где метод .observe() следит за чем-то и он содержит 2 аргумента в себе:
// observer.observe(node, config);
// node - это наш 1-й аргумент (элемент) за кот-м нам и нужно следить,
// config – это объект с булевыми параметрами «на какие изменения реагировать»:
// childList – изменения в непосредственных детях node,
// subtree – во всех потомках node,
// attributes – в атрибутах node,
// attributeFilter – массив имён атрибутов, чтобы наблюдать только за выбранными.
// characterData – наблюдать ли за node.data (текстовое содержимое),

// Например <div> с атрибутом contentEditable (пишется он в html) позволяет нам сфокусироваться на элементе, 
// например, кликнув, и отредактировать содержимое.
// <div contentEditable id="elem">Отредактируй <b>меня</b>, пожалуйста</div>
// после этого мы сможет писать и редактировать содержимое прямо в браузере нашего сайта, т.е клиент сам сможет менять содер-е
// такое часто испол-ся при разработке админ-панелей!


const box = document.querySelector('.box');
// созд-м сущность(объект) след-ю за нашим элементом, где в () в виде колбек фун-и у нас будет список изменений MutationRecord
let observer = new MutationObserver(MutationRecord => {
    // указываем что делать с получ-й инфор-й
    console.log(MutationRecord);
});
// нужно запомнить что observer сраб-т у нас уже после измен-й, т.е. мы не можем что то сделать во время действия
// мы уже работаем с резул-м изменений

// если нам нужно дать команду observer перестать следить за чем-то, вызыв-м команду-метод .disconnect()
observer.disconnect();

// теперь нам нужно сказать что нужно следить за вот этим эле-м и если что меняется то выпол-й след-ю функ-ю
// метод .observe() следит за чем-то и он содер-т 2 аргумента, где 1-й аргумент это наш элемент box
// за кот-м нам и нужно следить
observer.observe(box, {
    // т.е. мы будем следить за childList, добав-ся или удал-ся у нас узлы и тд
    // и когда мы что-то изменим в элементе, напр. напишем что то внутри мы в консоле увидим соот. измен-я
    // а именно массив с объектами внутри [MutationRecord], т.е. внутри этого массива будут все изменения
    // которые произошли внутри этого события MutationRecord
    childList: true
    // т.е. тут мы выбираем элемент за которым хотим следить, изменения за кото-ми хотим следить
    // и в фун-и обработчике выше(MutationRecord) мы можем указать какие действия при этом хотим делать
});


// ResizeObserver работает по схожему принципу с MutationObserver, только отслеж-т измен-е размеров элементов
// ResizeObserver — полезный примитив. Он реагирует на изменение размера любого из наблюдаемых элементов, 
// независимо от того, что вызвало это изменение. Он также обеспечивает доступ к новому размеру наблюдаемых элементов
// подр-е https://web.dev/i18n/ru/resize-observer/

